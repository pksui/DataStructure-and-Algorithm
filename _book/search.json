[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "HUAWEIOD",
    "section": "",
    "text": "Preface\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "4  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "Stack.html",
    "href": "Stack.html",
    "title": "2  Stack",
    "section": "",
    "text": "3 华为OD真题"
  },
  {
    "objectID": "Stack.html#栈2024d-密码输入检测",
    "href": "Stack.html#栈2024d-密码输入检测",
    "title": "2  Stack",
    "section": "3.1 【栈】2024D-密码输入检测",
    "text": "3.1 【栈】2024D-密码输入检测\n题目描述\n给定用户密码输入流 input，输入流中字符&lt;表示退格，可以清除前一个输入的字符，请你编写程序，输出最终得到的密码字符，并判断密码是否满足如下的密码安全要求。 密码安全要求如下：\n\n密码长度&gt;=8;\n密码至少需要包含 1 个大写字母;\n密码至少需要包含 1 个小写字母;\n密码至少需要包含 1 个数字;\n密码至少需要包含 1 个字母和数字以外的非空白特殊字符\n\n注意空串退格后仍然为空串，且用户输入的字符串不包含&lt;字符和空白字符。\n输入描述\n用一行字符串表示输入的用户数据，输入的字符串中’&lt;’字符标识退格，用户输入的字符串不包含空白字符，例如：ABC&lt;c89%000&lt;\n输出描述\n输出经过程序处理后，输出的实际密码字符串，并输出改密码字符串是否满足密码安全要求。两者间由’,’分隔， 例如：ABc89%00,true\n示例\n\n输入：ABC&lt;c89%000&lt;\n\n\n输出：ABc89%00,true\n\n\nimport time"
  },
  {
    "objectID": "Stack.html#华为od真题",
    "href": "Stack.html#华为od真题",
    "title": "2  栈",
    "section": "2.1 华为OD真题",
    "text": "2.1 华为OD真题\n\n2.1.1 【栈】2024D-密码输入检测\n题目描述\n给定用户密码输入流 input，输入流中字符&lt;表示退格，可以清除前一个输入的字符，请你编写程序，输出最终得到的密码字符，并判断密码是否满足如下的密码安全要求。 密码安全要求如下：\n\n密码长度&gt;=8;\n密码至少需要包含 1 个大写字母;\n密码至少需要包含 1 个小写字母;\n密码至少需要包含 1 个数字;\n密码至少需要包含 1 个字母和数字以外的非空白特殊字符\n\n注意空串退格后仍然为空串，且用户输入的字符串不包含&lt;字符和空白字符。\n输入描述\n用一行字符串表示输入的用户数据，输入的字符串中’&lt;’字符标识退格，用户输入的字符串不包含空白字符，例如：ABC&lt;c89%000&lt;\n输出描述\n输出经过程序处理后，输出的实际密码字符串，并输出改密码字符串是否满足密码安全要求。两者间由’,’分隔， 例如：ABc89%00,true\n示例\n\n输入：ABC&lt;c89%000&lt;\n\n\n输出：ABc89%00,true\n\n解题思路\n我认为这道题是需要考虑两种特殊情况，第一种是输入出现了空格，第二种是输入出现了&lt;。如果是第一种情况，直接略过即可，要是第二种情况就比较复杂，我们需要把前面一个 存入的答案字符删去，而且如果前面没有答案字符的话，就略过。这意味着我们每次读取输入的字符串的内容，并不是存入即好，有些元素是要被抛弃掉的，而且那些被抛弃掉的元素 都是刚刚放入的或者是刚刚放入不久的。\n这里就很容易想到用栈的方式，当遇到除了&lt;和空格的字符时，我们把它存入栈中。当遇到&lt;时，我们把栈中的最上面的元素弹出来（这里还要考虑一下栈为空的情况），遍历之后得到 的Stack是一个list。之前我还想如何把Stack中的数据按照字符串的形式表现出来，本来想的是也是在栈中取数据的方式，从上面一个一个取，后来想到，它就是一个list（），我可以直接 按照list的顺序通过\"\".join(list)的形式变成字符串。\n最终还是要看看密码的字符串是否符合规则，这里用了any()函数来判断五条规定是否成立，然后返回密码内容和判断对错的情况，最后还是有一些小插曲，在print()操作中有一些小细节 要注意一下。\n\n# 首先把字符串输入进来，用变量ex储存\nex = input()\n\n#我们需要返回密码是否有效，所以要设置一个bool的变量\n\nisError = False\n\n# 我们要用一个栈来储存输入的字符串内容，但是不应该包含‘&lt;’，所以每次一旦遇到‘&lt;’，就该停下来看看\nStack = list()\n\n# 开始进入一个循环，逐个读取字符串的内容\nfor ch in ex:\n  # 目前看来字符串的内容就分为两类，一类是‘&lt;’，另一类是其他符号\n  if ch == '&lt;':\n    # 这里注意一下，如果栈中没有数据了，我们不能弹出最上面的数据，所以一定要看看栈是否为空\n    if Stack:\n      Stack.pop()\n  elif ch == \" \": # 如果是空白字符，不能算入密码内\n    continue\n\n  else:# 这是其他符号的情况\n    Stack.append(ch)\n# 结束遍历之后，我们会得到一个list，这个按照list从0到n-1的顺序就是密码的内容了，现在我们需要把密码展现出来并且看看它是否合理\n\n# 首先来看看它是否长度大于等于8\nflag1 = len(Stack) &gt;= 8\n\n# 然后来看栈里面是否有大写字母的存在，如果有的话，就返回对，如果一个都没有的话就返回错，这里用到any()函数\n# any函数是内置函数（就是Python自带的函数），用于判断列表、远足等结构中是否至少有一个元素为真。如果都不是真的话，返回否；至少有一个为真的话，返回是。\n\nflag2 = any(x.isupper() for x in Stack)  # 这里注意括号里的整体是一个list的生成器，其中每一个元素都是bool类型\n\n#检测是否有小写字母\nflag3 = any(x.islower() for x in Stack)\n\n#检测是否有数字\n\nflag4 = any(x.isdigit() for x in Stack)\n\n# 检测是否有除了空白字符外的特殊字符\n\nflag5 = any( (not x.isalpha()) and (not x.isdigit()) for x in Stack)\n\n# 如果五种情况都对的话，那么返回的情况是对，否则是错\n\nisError = not (flag1 and flag2 and flag3 and flag4 and flag5)\n\n#用`\"\".join(list)`把列表里面的每个元素合起来变成一个字符串\n\nprint(\"\".join(Stack)+\",\"+('true' if not isError else 'false') )\n# 最后一行操作还挺复杂的，如果最后的if和else不加括号的话，测试结果只能对一半，你猜猜为什么？\n\n\n\n2.1.2 【栈】2023C-火星文计算2\n题目描述\n已知火星人使用的运算符号为#、$，他们与地球人的等价公式如下：\n\nx#y = 4*x + 3*y + 2\nx$y = 2*x + y + 3\n\n其中x与y是无符号整数，地球人公式按照C语言规则进行计算，火星人公式中的#符优先级高于$，相同的运算符按从左到右的顺序计算。\n输入描述\n火星人字符串表达式结尾不带回车换行\n字符串为仅有无符号整数和操作符组成的计算表达式\n\n用例保证字符串中操作数与操作符之间没有任何分隔符\n用例保证操作数取值范围为32位无符号整数\n保证输入以及计算结果不会出现整型溢出\n保证输入的字符串为合法的求值报文，例如：123#4&576$78\n保证不会出现非法的求值报文\n\n#4$5这种缺少操作数\n4$5#这种缺少操作数\n4#$5这种缺少操作数\n4 $5有空格\n3+4-5*6/7有其他操作符\n12345678987654321$5432132位整数溢出\n\n\n输出描述\n根据火星人字符串输出计算结果，结尾不带回车换行\n实例\n\n输入：7#6$5#12\n\n\n输出：157\n\n\n说明：7#6$5#12 = (4*7 + 3*6 + 2)$5#12 = 48$(4 * 5 + 3 * 12 + 2) = 48$58 = 2 * 48 + 58 + 3 = 157\n\n解题思路\n这道题看似是一道计算题，定义了两种运算，其中的#运算比$运算优先级更高，而且也是从左往右计算，这特别像乘法与加法运算一样。按照人类的计算来讲，就是挨个读取输入的数据和运算符号，并且及时计算。但是及时挨个输入，我也不能一遇到数据就可以进行计算，万一后面的计算符号优先等级更高，我就必须先把前面算得的数据放起来，开始进行后面的数据计算，然后再把整体从左往右进行计算。\n通过上面叙述，这里注意到题目的特性，既要读取数据，又要计算数据，有时还要搁置数据，并且数据不会被搁置的太长。这很显然要用栈来操作，如果被处理的数据总是那些很早之前就存入进去的，我们就要用队列来实现。\n对于读取数据好说，看到数据就记下，重要的是什么时候把它放到栈里面去呢？有两个选择：\n\n完整地读完一个数据，就存储到栈里面去\n等遇到计算符号时，把数据存储到栈里面去\n\n如果是第一种情况，我们不仅要读取数据，还要看数据下一位是否是运算符号，如果是运算符号，我们就停止输入数字，把所得到的数字进行整合化成一个数据，然后把它存到栈中去。\n如果是第二种情况，我们不用考虑已经读取到的字符是否真的构成一个完整的数据，只要我遇到了一个运算字符就说明前面所有的输入数字字符构成一个数据，那么当我遇到数字字符的时候，只需把它记下，再加上前面的数据*10即可。\n貌似第二种方式更加便捷一些，因为如果是第一种方式，我要提前预判后面的操作，读取数据时不能用for ch in s的操作，只能是 for i in range(0,len - 1)，这样也不是不行，但是肯定不如前面那样逻辑清楚，所以一般我是不愿意那样做的。第二种方式不用提前预判，这在逻辑和代码上减缓了我们的压力，谁都不愿意循环中套一个循环。\n这样压力就转移到了遇到计算字符的条件下该执行什么样的操作，这里还有两种情况：\n\n遇到低优先级计算符\n遇到高优先级计算符\n\n如果是第二种情况，毫无疑问马上进行计算，把栈中最上面的两个元素弹出，然后再把计算的结果放入栈中。但是别忘了运算符号在要计算了两个数据中间，所以还缺一个数据不能进行计算。要等到下一个数据进栈后，马上进行计算，下一个数据什么时候进栈呢？就是遇见下一个运算符，这里注意不管是什么等级的运算符，我们都要去判断，除了把数据进栈后，是否还要进行运算。\n当第一种情况遇见低等级的计算符时，有下面两种情况：\n\n4#2&4\n4$2$4\n\n第一种情况，很显然我们要马上对4和2进行计算。第二种情况，不用进行计算直接存储数据即可。如何实现这样的操作呢？我们就要在全局中设立一个变量记录是否上次遇见的计算符是高等级的计算符，如果是就计算，如果不是就不计算。\n当进行完循环的时候，我们有个bug，就是最后一个数字我们无法让它存入栈中，而题目中说结尾没有任何其他字符，而我们让数据进栈并且计算只有一种情况，那就是遇见非数字的情况，那么我们可以人为的改变输入的字符串，在最后我们可以加一个“ ”空格进去，这时读取玩最后一个数字的时候，接着读取到了空格，这时就可以针对最后一个数据进行存储计算了，最终得到了进行完最高等级运算的数据列表。\n然后要按照列表里的数据，按照顺序一个挨着一个进行低等级计算。肯定要进行遍历，但是不能一上来就从第一个开始遍历。我们先提取第一个数据，然后从第二个数据开始遍历，首先跟第二个数据跟第一个数据进行计算，得出来的结果放到变量中，遍历第三个时，跟这个变量进行计算，得出来的结果再放入到同样的变量中，最终得出来的结果就是按照顺序计算低等级运算的。\n\n# 读取字符串\ns = input()\ns = s + \" \"\n'''\n这里有两个运算，无论是什么逻辑解决这道题，我们都需要大量应用这两个运算，如果每次\n都按照题目的运算顺序去写出来的话，太过麻烦，所以我们要设立两个运算函数，这样如果\n要进行运算时，直接调用即可。\n'''\ndef cal_well(x,y):\n  return 4 * x + 3 * y + 2\n\ndef cal_dollor(x,y):\n  return 2 * x + y + 3\n\n'''\n这里我们思考一下，对于进行例如7#6$5#12这样的运算，需要对数据进行存储，需要我们搞清楚优先级顺序。\n按照正常逻辑，我们应该先进行#运算，然后在进行$运算。也就是说我们不能直接把所有的数据直接存储起\n来，我们首先应该计算完#运算之后，把所有的数据存储起来，在按照顺序把数据进行$运算。那现在的问题\n就是如何计算完#之后，把数据按照顺序存储起来？很明显，我们要按照栈的方式进行数据存储，当遇到#的\n时候，把两个数据进行运算得到的结果再储存到栈中，这样能保持栈中的元素是进行#运算之后的元素，遇到\n$时，什么都不干，继续存储$之后的数字（因为我们只计算#），最终得到的栈的元素就是我们进行完#运算\n之后要进行$的数据。\n'''\n\n# 构建存储数据的栈\nstore = list()\n\nnum = 0 # 用于储存数据\n\nmeetWell = False  # 是否遇到#号\n# 遍历字符串\nfor ch in s:\n  if ch.isdigit():\n    #数字有可能是两位数或三位数以上，所以不能直接存入栈中，我们要让之前的数据乘上十倍再加现在的数\n    num = num * 10 + int(ch)\n  else:# 这里是#和$的情况\n\n    #首先遇到这个最高优先级的计算符号，我们要把之前的数据存储起来,并且要把单个数据存储num归零\n    #这样好进行下一个数据的存储\n    store.append(num)\n    num = 0\n    # 如果是进行'4 # 3 $ 5'的计算，我们到这步只是把4存储了起来，到3的时候必须让4跟3进行#运算后得到的数据\n    # 存储到栈中\n    '''\n    现在面临两个选择，第一个选择是在遇到#号时，直接进行计算，但是下一个数字我们还没有把它存入到栈中；\n    第二个选择是等到下一个数字时，我们把栈中最上面的元素弹出来，进行计算然后放到栈中。\n    这里我选择第一个选择，为什么呢？因为如果执行第二个选择的话，就要在ch.isdigit()这里去进行进栈操作，\n    这样的话遇到符号要考虑进栈，遇见数字还要考虑进栈。逻辑上，包括代码上都更加复杂了。\n    那就要在遇见算数符号时，都要考虑一下是否进行计算，很显然，第一次遇见算数符号#时不计算，第二次遇见算数\n    符号（不管是否为#）时就要计算了，所以条件我们就不能只是#，应该是‘#$’，这里就直接除了数字之外的else即可。\n    另外要注意，我们这里设置一个变量记录是否遇到了#号，我们把这个变量是否改变的代码放在执行计算的后面，这样\n    第一次执行else里的代码时，我们没遇到#，就不执行，然后在最后把meetweel改为True，等下次遇见计算符号时，就\n    可以计算了，然后再看遇见的符号是不是#，如果是的话，就改meetWeel为True，如果不是就改为Fasle。这样也就避\n    免了，遇见很多次$符号时，还计算的错误情况，保证只进行#运算。\n    '''\n    if meetWell:\n      y = store.pop()\n      x = store.pop()\n      store.append(cal_well(x,y))\n\n    if ch == '#':\n      meetWell = True\n    else:\n      meetWell = False\n\n# 题目中说输入的字符串结尾最后一个数字后面啥都没有，也就意味着我们的计算逻辑是有缺陷的，\n# 最后一个数字没有经过我们的计算，甚至连进入栈的资格都没有。要想让最后一个数字被计算并且\n# 能进栈，必须在字符串内容读取完了之后，还要再读取一个非数字和计算符号的字符，这样就会\n# 进入到else的状态中，把最后一个数字输入进栈，并且进行判断是否计算，才能得到最终的结果。\n\n# 接下来就要去计算$了\n# 先把栈中的第一个元素记录下来，通过变量res进行存储，然后挨个循环列表跟res进行$计算，\n# 再把结果记为res，最终就会得出答案\nres = store[0]\nfor i in store[1:]:\n  res = cal_dollor(res,i)\n\nprint(res)"
  },
  {
    "objectID": "Queue.html#华为od真题",
    "href": "Queue.html#华为od真题",
    "title": "3  队列",
    "section": "3.1 华为OD真题",
    "text": "3.1 华为OD真题\n\n3.1.1 【队列】2024C-篮球游戏\n题目描述\n幼儿园里有一个倒放的圆筒，它是一个线性结构，允许在桶的右边将篮球放入，可以在桶的左边和右边将篮球取出。每个篮球有单独的编号，老师可以连续放入一个或多个篮球，小朋友可以在桶左边或右边将篮球取出，当桶里只有一个篮球的情况下，必须从左边取出。\n如老师按顺序放入1、2、3、4、5共5个编号的篮球，那么小朋友可以依次取出的编号为1、2、3、4、5或者3、1、2、4、5编号的篮球，无法取出5、1、3、2、4编号的篮球。\n其中3、1、2、4、5的取出场景为：连续放入1、2、3号 -&gt; 从右边取出3号 -&gt; 从左边取出1号 -&gt; 从左边取出2号 -&gt; 放入4号 -&gt; 从左边取出4号 -&gt; 放入5号 -&gt; 从左边取出5号，简单起见，我们以L表示左,R表示右，此时的篮球的依次取出序列为RLLLL。\n输入描述\n每次输入包括一个测试用例：\n\n第一行的数字作为老师依次放入的篮球编号\n第二行的数字作为要检查是否能够按照放入顺序取出的篮球编号\n\n其中篮球编号用逗号进行分割。\n输出描述\n对于每个篮球的取出序列，如果确实可以获取，请打印出其按照左右方向的操作的取出顺序，如果无法获取则打印No\n\n1 &lt;= 篮球的编号， 篮球的个数 &lt;= 200\n篮球上的数字不重复\n输出的结果中LR的必须为大写\n\n示例\n\n输入：4,5,6,7,0,1,2\n\n\n输入: 6,4,0,1,2,5,7\n\n\n输出：RLRRRLL\n\n解题思路\n这道题的篮球一会从左边取，一会从右边取，很显然是一道以队列为存储对象的题目。我们先去一个一个用队列存储老师放进来的篮球，每放进一个，我们都要跟排出篮球的顺序中的首个序列号进行对比，如果一样就排出，如果不一样，就继续存储下一个篮球。但是如果恰巧一样，我们把它排出去了，就继续接收下一个篮球了吗？\n不是的，我们要看排出篮球后改变的队列排序，这时排出篮球序列也变化了。我们要让改变后的提取排序的第一项跟输入队列的左右两边进行对比，首先要跟左边进行对比，为什么呢？因为如果输入的篮球只剩下一个，而且恰巧这个时候，它又被排出去，很显然我们要从左边把它排出去，考虑到这个情况，我们很显然要以队列的最左边元素与输出数列的第一个进行比较。\n那如果比较成功了之后，我们就继续进行放入篮球吗？nono，我们再继续进行对比，而且这时的对比情况也是一样的。那我们是在每种情况下都输入一遍吗？不是，我们应该统一进行管理，用While循环进行整体遍历。而且我们注意到一个现象，就是无论是大的遍历还是小的遍历，输出数列的序列号总是要增长的。我们就以它的序列为遍历的标准，这时还要注意，万一队列里没了元素，我们就不能继续进入循环了，因为那样会导致指针冒出来，所以应该再加上队列是否为空，如果为空就跳过循环，去加元素到队列之中。\n当然，每次进行弹出操作是，我们都要在结果的字符串中加上“L”或者“R”。最后得到的队列如果为空，则说明所有篮球都可以按照顺序排出来，否则就排不出了，我们打印一个“NO”出来。\n\n# 这道题很明显要用队列来解决了，我们首先要接收两个字符串，把它们先变成list形式储存\nteaBasket = list(map(int, input().split(\",\")))\ncheBasket = list(map(int, input().split(\",\")))\n\n# 设置储存输入的篮球序列的队列，这里要引入一个module\nfrom collections import deque\ntest = deque()\n# 我们最后要返回结果，里面包含字符“LEFT”和“RIGHT”\nres = \"\"\n\"\"\"\n我们首先要用队列去挨个读取放入的篮球序列，每放入一个篮球，就要跟取出篮球序列中的未被取出的篮球进行比较，如果不是，则读取\n下一个，如果是就要把它弹出去。这里注意：不仅放入篮球会改变左右两边的篮球序列号，弹出也会改变，\n而且未被取出的篮球序列一旦跟左右两边的篮球序号对上，我们就要看下一位是否跟新生成左右两边的篮球序号对应，\n这里很显然执行弹出操作时，还要继续往下进行检验。看来不得不用while循环了。,一旦用while循环，则必须要有\nindex号，我们要设立一个变量cheIndex来储存它。\n\"\"\"\ncheIndex = 0\n\nfor ch in teaBasket:\n    #首先把元素加入到队列中区\n    test.append(ch)\n    #其次要判断加入的元素是否跟未排出的篮球队列的第一个元素相符\n    '''\n    但是加入的元素是什么？是deque[-1],我让它去跟排出列表相比。那如果它是第一个且与排除队列中的元素\n    相等，这时，我就要从右边把deque排出元素，从右拿出，这是不行滴，因为如果放入的只有一个篮球的话，\n    必须要从左边拿出。\n    那么该怎么办呢？虽然我从右边放进一个新的篮球，但是我对比的时候，应该先让队列的左边第一个\n    元素去跟比，对吧？因为如果只进一个元素的话，第一个元素也是它，最后一个元素也是它，先让第一个\n    元素跟它比，就从左边拿出了。\n    还有一种情况就是队列中不止一个元素，有一个以上，那好像从左边跟未出列的元素进行对比，有点\n    费周章，因为肯定不是嘛，要不然怎么会新增加一个队列元素呢？但是这样能保证从左边拿出，而且\n    当拿出后，你还要往下一步看，是否我队列的左边和右边跟新出现的列表中的元素相等？这时再进入到\n    这个循环中，就可以继续对比了，所以要把整体设置成一个循环，先从左边看是否相等就不浪费了。\n    '''\n    # 这里还必须要考虑一种情况，就是如果队列已经为空，\n    # 那么再进入这个循环中，就没有test[0]了\n    # 所以必须加上判断队列是否为空\n    while test and cheIndex &lt; len(teaBasket):# while保证它能一直判断\n        if test[0] == cheBasket[cheIndex]: # 本来是进行这个操作的，然后如果成功就继续判断，\n            test.popleft()              # 判断的内容还是跟进来一个新元素相同，所以就整体化\n            cheIndex += 1                # 为一个大循环\n            res += 'L'\n        elif test[-1] == cheBasket[cheIndex]:\n            test.pop()\n            cheIndex += 1\n            res += 'R'\n        else:\n            break\n\nif test:\n    print(\"NO\")\nelse:\n    print(res)"
  }
]