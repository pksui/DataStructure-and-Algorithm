# 栈
## 华为OD真题

### [【栈】2024D-密码输入检测](https://oj.algomooc.com/problem.php?id=2605)

**题目描述**

给定用户密码输入流 `input`，输入流中字符`<`表示退格，可以清除前一个输入的字符，请你编写程序，输出最终得到的密码字符，并判断密码是否满足如下的密码安全要求。
密码安全要求如下：

1. 密码长度>=8;
2. 密码至少需要包含 1 个大写字母;
3. 密码至少需要包含 1 个小写字母;
4. 密码至少需要包含 1 个数字;
5. 密码至少需要包含 1 个字母和数字以外的非空白特殊字符

注意空串退格后仍然为空串，且用户输入的字符串不包含`<`字符和空白字符。

**输入描述**

用一行字符串表示输入的用户数据，输入的字符串中'<'字符标识退格，用户输入的字符串不包含空白字符，例如：`ABC<c89%000<`

**输出描述**

输出经过程序处理后，输出的实际密码字符串，并输出改密码字符串是否满足密码安全要求。两者间由','分隔， 例如：`ABc89%00,true`

**示例**

> 输入：ABC<c89%000<

> 输出：ABc89%00,true

**解题思路**

我认为这道题是需要考虑两种特殊情况，第一种是输入出现了空格，第二种是输入出现了`<`。如果是第一种情况，直接略过即可，要是第二种情况就比较复杂，我们需要把前面一个
存入的答案字符删去，而且如果前面没有答案字符的话，就略过。这意味着我们每次读取输入的字符串的内容，并不是存入即好，有些元素是要被抛弃掉的，而且那些被抛弃掉的元素
都是刚刚放入的或者是刚刚放入不久的。

这里就很容易想到用栈的方式，当遇到除了`<`和空格的字符时，我们把它存入栈中。当遇到`<`时，我们把栈中的最上面的元素弹出来（这里还要考虑一下栈为空的情况），遍历之后得到
的Stack是一个list。之前我还想如何把Stack中的数据按照字符串的形式表现出来，本来想的是也是在栈中取数据的方式，从上面一个一个取，后来想到，它就是一个list（），我可以直接
按照list的顺序通过`"".join(list)`的形式变成字符串。

最终还是要看看密码的字符串是否符合规则，这里用了`any()`函数来判断五条规定是否成立，然后返回密码内容和判断对错的情况，最后还是有一些小插曲，在`print()`操作中有一些小细节
要注意一下。

```{python, eval=false}
#| eval: false

# 首先把字符串输入进来，用变量ex储存
ex = input()

#我们需要返回密码是否有效，所以要设置一个bool的变量

isError = False

# 我们要用一个栈来储存输入的字符串内容，但是不应该包含‘<’，所以每次一旦遇到‘<’，就该停下来看看
Stack = list()

# 开始进入一个循环，逐个读取字符串的内容
for ch in ex:
  # 目前看来字符串的内容就分为两类，一类是‘<’，另一类是其他符号
  if ch == '<':
    # 这里注意一下，如果栈中没有数据了，我们不能弹出最上面的数据，所以一定要看看栈是否为空
    if Stack:
      Stack.pop()
  elif ch == " ": # 如果是空白字符，不能算入密码内
    continue

  else:# 这是其他符号的情况
    Stack.append(ch)
# 结束遍历之后，我们会得到一个list，这个按照list从0到n-1的顺序就是密码的内容了，现在我们需要把密码展现出来并且看看它是否合理

# 首先来看看它是否长度大于等于8
flag1 = len(Stack) >= 8

# 然后来看栈里面是否有大写字母的存在，如果有的话，就返回对，如果一个都没有的话就返回错，这里用到any()函数
# any函数是内置函数（就是Python自带的函数），用于判断列表、远足等结构中是否至少有一个元素为真。如果都不是真的话，返回否；至少有一个为真的话，返回是。

flag2 = any(x.isupper() for x in Stack)  # 这里注意括号里的整体是一个list的生成器，其中每一个元素都是bool类型

#检测是否有小写字母
flag3 = any(x.islower() for x in Stack)

#检测是否有数字

flag4 = any(x.isdigit() for x in Stack)

# 检测是否有除了空白字符外的特殊字符

flag5 = any( (not x.isalpha()) and (not x.isdigit()) for x in Stack)

# 如果五种情况都对的话，那么返回的情况是对，否则是错

isError = not (flag1 and flag2 and flag3 and flag4 and flag5)

#用`"".join(list)`把列表里面的每个元素合起来变成一个字符串

print("".join(Stack)+","+('true' if not isError else 'false') )
# 最后一行操作还挺复杂的，如果最后的if和else不加括号的话，测试结果只能对一半，你猜猜为什么？
```


### [【栈】2023C-火星文计算2](https://oj.algomooc.com/problem.php?id=2607)

**题目描述**

已知火星人使用的运算符号为`#`、`$`，他们与地球人的等价公式如下：

+ `x#y = 4*x + 3*y + 2`
+ `x$y = 2*x + y + 3`

其中`x`与`y`是无符号整数，地球人公式按照C语言规则进行计算，火星人公式中的`#`符优先级高于`$`，相同的运算符按从左到右的顺序计算。

**输入描述**

火星人字符串表达式结尾不带回车换行

字符串为仅有无符号整数和操作符组成的计算表达式

1. 用例保证字符串中操作数与操作符之间没有任何分隔符
2. 用例保证操作数取值范围为`32`位无符号整数
3. 保证输入以及计算结果不会出现整型溢出
4. 保证输入的字符串为合法的求值报文，例如：`123#4&576$78`
5. 保证不会出现非法的求值报文
    + `#4$5`这种缺少操作数
    + `4$5#`这种缺少操作数
    + `4#$5`这种缺少操作数
    + `4 $5`有空格
    + `3+4-5*6/7`有其他操作符
    + `12345678987654321$54321`32位整数溢出

**输出描述**

根据火星人字符串输出计算结果，结尾不带回车换行

**实例**

> 输入：7#6$5#12

> 输出：157

> 说明：`7#6$5#12 = (4*7 + 3*6 + 2)$5#12 = 48$(4 * 5 + 3 * 12 + 2) = 48$58 = 2 * 48 + 58 + 3 = 157`

**解题思路**

这道题看似是一道计算题，定义了两种运算，其中的#运算比$运算优先级更高，而且也是从左往右计算，这特别像乘法与加法运算一样。按照人类的计算来讲，就是挨个读取输入的数据和运算符号，并且及时计算。但是及时挨个输入，我也不能一遇到数据就可以进行计算，万一后面的计算符号优先等级更高，我就必须先把前面算得的数据放起来，开始进行后面的数据计算，然后再把整体从左往右进行计算。

通过上面叙述，这里注意到题目的特性，既要读取数据，又要计算数据，有时还要搁置数据，并且数据不会被搁置的太长。这很显然要用栈来操作，如果被处理的数据总是那些很早之前就存入进去的，我们就要用队列来实现。

对于读取数据好说，看到数据就记下，重要的是什么时候把它放到栈里面去呢？有两个选择：

+ 完整地读完一个数据，就存储到栈里面去
+ 等遇到计算符号时，把数据存储到栈里面去

如果是第一种情况，我们不仅要读取数据，还要看数据下一位是否是运算符号，如果是运算符号，我们就停止输入数字，把所得到的数字进行整合化成一个数据，然后把它存到栈中去。

如果是第二种情况，我们不用考虑已经读取到的字符是否真的构成一个完整的数据，只要我遇到了一个运算字符就说明前面所有的输入数字字符构成一个数据，那么当我遇到数字字符的时候，只需把它记下，再加上前面的数据*10即可。

貌似第二种方式更加便捷一些，因为如果是第一种方式，我要提前预判后面的操作，读取数据时不能用for ch in s的操作，只能是 for i in range(0,len - 1)，这样也不是不行，但是肯定不如前面那样逻辑清楚，所以一般我是不愿意那样做的。第二种方式不用提前预判，这在逻辑和代码上减缓了我们的压力，谁都不愿意循环中套一个循环。

这样压力就转移到了遇到计算字符的条件下该执行什么样的操作，这里还有两种情况：

- 遇到低优先级计算符
- 遇到高优先级计算符

如果是第二种情况，毫无疑问马上进行计算，把栈中最上面的两个元素弹出，然后再把计算的结果放入栈中。但是别忘了运算符号在要计算了两个数据中间，所以还缺一个数据不能进行计算。要等到下一个数据进栈后，马上进行计算，下一个数据什么时候进栈呢？就是遇见下一个运算符，这里注意不管是什么等级的运算符，我们都要去判断，除了把数据进栈后，是否还要进行运算。

当第一种情况遇见低等级的计算符时，有下面两种情况：

- `4#2&4`
- `4$2$4`

第一种情况，很显然我们要马上对4和2进行计算。第二种情况，不用进行计算直接存储数据即可。如何实现这样的操作呢？我们就要在全局中设立一个变量记录是否上次遇见的计算符是高等级的计算符，如果是就计算，如果不是就不计算。

当进行完循环的时候，我们有个bug，就是最后一个数字我们无法让它存入栈中，而题目中说结尾没有任何其他字符，而我们让数据进栈并且计算只有一种情况，那就是遇见非数字的情况，那么我们可以人为的改变输入的字符串，在最后我们可以加一个“ ”空格进去，这时读取玩最后一个数字的时候，接着读取到了空格，这时就可以针对最后一个数据进行存储计算了，最终得到了进行完最高等级运算的数据列表。

然后要按照列表里的数据，按照顺序一个挨着一个进行低等级计算。肯定要进行遍历，但是不能一上来就从第一个开始遍历。我们先提取第一个数据，然后从第二个数据开始遍历，首先跟第二个数据跟第一个数据进行计算，得出来的结果放到变量中，遍历第三个时，跟这个变量进行计算，得出来的结果再放入到同样的变量中，最终得出来的结果就是按照顺序计算低等级运算的。


```{python}
#| eval: false

# 读取字符串
s = input()
s = s + " "
'''
这里有两个运算，无论是什么逻辑解决这道题，我们都需要大量应用这两个运算，如果每次
都按照题目的运算顺序去写出来的话，太过麻烦，所以我们要设立两个运算函数，这样如果
要进行运算时，直接调用即可。
'''
def cal_well(x,y):
  return 4 * x + 3 * y + 2

def cal_dollor(x,y):
  return 2 * x + y + 3

'''
这里我们思考一下，对于进行例如7#6$5#12这样的运算，需要对数据进行存储，需要我们搞清楚优先级顺序。
按照正常逻辑，我们应该先进行#运算，然后在进行$运算。也就是说我们不能直接把所有的数据直接存储起
来，我们首先应该计算完#运算之后，把所有的数据存储起来，在按照顺序把数据进行$运算。那现在的问题
就是如何计算完#之后，把数据按照顺序存储起来？很明显，我们要按照栈的方式进行数据存储，当遇到#的
时候，把两个数据进行运算得到的结果再储存到栈中，这样能保持栈中的元素是进行#运算之后的元素，遇到
$时，什么都不干，继续存储$之后的数字（因为我们只计算#），最终得到的栈的元素就是我们进行完#运算
之后要进行$的数据。
'''

# 构建存储数据的栈
store = list()

num = 0 # 用于储存数据

meetWell = False  # 是否遇到#号
# 遍历字符串
for ch in s:
  if ch.isdigit():
    #数字有可能是两位数或三位数以上，所以不能直接存入栈中，我们要让之前的数据乘上十倍再加现在的数
    num = num * 10 + int(ch)
  else:# 这里是#和$的情况

    #首先遇到这个最高优先级的计算符号，我们要把之前的数据存储起来,并且要把单个数据存储num归零
    #这样好进行下一个数据的存储
    store.append(num)
    num = 0
    # 如果是进行'4 # 3 $ 5'的计算，我们到这步只是把4存储了起来，到3的时候必须让4跟3进行#运算后得到的数据
    # 存储到栈中
    '''
    现在面临两个选择，第一个选择是在遇到#号时，直接进行计算，但是下一个数字我们还没有把它存入到栈中；
    第二个选择是等到下一个数字时，我们把栈中最上面的元素弹出来，进行计算然后放到栈中。
    这里我选择第一个选择，为什么呢？因为如果执行第二个选择的话，就要在ch.isdigit()这里去进行进栈操作，
    这样的话遇到符号要考虑进栈，遇见数字还要考虑进栈。逻辑上，包括代码上都更加复杂了。
    那就要在遇见算数符号时，都要考虑一下是否进行计算，很显然，第一次遇见算数符号#时不计算，第二次遇见算数
    符号（不管是否为#）时就要计算了，所以条件我们就不能只是#，应该是‘#$’，这里就直接除了数字之外的else即可。
    另外要注意，我们这里设置一个变量记录是否遇到了#号，我们把这个变量是否改变的代码放在执行计算的后面，这样
    第一次执行else里的代码时，我们没遇到#，就不执行，然后在最后把meetweel改为True，等下次遇见计算符号时，就
    可以计算了，然后再看遇见的符号是不是#，如果是的话，就改meetWeel为True，如果不是就改为Fasle。这样也就避
    免了，遇见很多次$符号时，还计算的错误情况，保证只进行#运算。
    '''
    if meetWell:
      y = store.pop()
      x = store.pop()
      store.append(cal_well(x,y))

    if ch == '#':
      meetWell = True
    else:
      meetWell = False

# 题目中说输入的字符串结尾最后一个数字后面啥都没有，也就意味着我们的计算逻辑是有缺陷的，
# 最后一个数字没有经过我们的计算，甚至连进入栈的资格都没有。要想让最后一个数字被计算并且
# 能进栈，必须在字符串内容读取完了之后，还要再读取一个非数字和计算符号的字符，这样就会
# 进入到else的状态中，把最后一个数字输入进栈，并且进行判断是否计算，才能得到最终的结果。

# 接下来就要去计算$了
# 先把栈中的第一个元素记录下来，通过变量res进行存储，然后挨个循环列表跟res进行$计算，
# 再把结果记为res，最终就会得出答案
res = store[0]
for i in store[1:]:
  res = cal_dollor(res,i)

print(res)  


```




