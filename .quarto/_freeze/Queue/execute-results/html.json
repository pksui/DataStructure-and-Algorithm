{
  "hash": "07977a7cf01fbb25c73d9a9f14e11f11",
  "result": {
    "markdown": "# 队列\n## 华为OD真题\n\n### [【队列】2024C-篮球游戏](https://oj.algomooc.com/problem.php?id=2698)\n\n**题目描述**\n\n幼儿园里有一个倒放的圆筒，它是一个线性结构，允许在桶的右边将篮球放入，可以在桶的左边和右边将篮球取出。每个篮球有单独的编号，老师可以连续放入一个或多个篮球，小朋友可以在桶左边或右边将篮球取出，当桶里只有一个篮球的情况下，必须从左边取出。\n\n如老师按顺序放入`1、2、3、4、5`共`5`个编号的篮球，那么小朋友可以依次取出的编号为`1、2、3、4、5`或者`3、1、2、4、5`编号的篮球，无法取出`5、1、3、2、4`编号的篮球。\n\n其中`3、1、2、4、5`的取出场景为：连续放入`1、2、3`号 -> 从右边取出`3`号 -> 从左边取出`1`号 -> 从左边取出`2`号 -> 放入`4`号 -> 从左边取出`4`号 -> 放入`5`号 -> 从左边取出`5`号，简单起见，我们以`L`表示左,`R`表示右，此时的篮球的依次取出序列为`RLLLL`。\n\n**输入描述**\n\n每次输入包括一个测试用例：\n\n1. 第一行的数字作为老师依次放入的篮球编号\n2. 第二行的数字作为要检查是否能够按照放入顺序取出的篮球编号\n\n其中篮球编号用逗号进行分割。\n\n**输出描述**\n\n对于每个篮球的取出序列，如果确实可以获取，请打印出其按照左右方向的操作的取出顺序，如果无法获取则打印`No`\n\n1. 1 <= 篮球的编号， 篮球的个数 <= 200\n2. 篮球上的数字不重复\n3. 输出的结果中`LR`的必须为大写\n\n**示例**\n\n> 输入：4,5,6,7,0,1,2\n\n> 输入: 6,4,0,1,2,5,7\n\n> 输出：RLRRRLL\n\n**解题思路**\n\n这道题的篮球一会从左边取，一会从右边取，很显然是一道以队列为存储对象的题目。我们先去一个一个用队列存储老师放进来的篮球，每放进一个，我们都要跟排出篮球的顺序中的首个序列号进行对比，如果一样就排出，如果不一样，就继续存储下一个篮球。但是如果恰巧一样，我们把它排出去了，就继续接收下一个篮球了吗？\n\n不是的，我们要看排出篮球后改变的队列排序，这时排出篮球序列也变化了。我们要让改变后的提取排序的第一项跟输入队列的左右两边进行对比，首先要跟左边进行对比，为什么呢？因为如果输入的篮球只剩下一个，而且恰巧这个时候，它又被排出去，很显然我们要从左边把它排出去，考虑到这个情况，我们很显然要以队列的最左边元素与输出数列的第一个进行比较。\n\n那如果比较成功了之后，我们就继续进行放入篮球吗？nono，我们再继续进行对比，而且这时的对比情况也是一样的。那我们是在每种情况下都输入一遍吗？不是，我们应该统一进行管理，用While循环进行整体遍历。而且我们注意到一个现象，就是无论是大的遍历还是小的遍历，输出数列的序列号总是要增长的。我们就以它的序列为遍历的标准，这时还要注意，万一队列里没了元素，我们就不能继续进入循环了，因为那样会导致指针冒出来，所以应该再加上队列是否为空，如果为空就跳过循环，去加元素到队列之中。\n\n当然，每次进行弹出操作是，我们都要在结果的字符串中加上“L”或者“R”。最后得到的队列如果为空，则说明所有篮球都可以按照顺序排出来，否则就排不出了，我们打印一个“NO”出来。\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n# 这道题很明显要用队列来解决了，我们首先要接收两个字符串，把它们先变成list形式储存\nteaBasket = list(map(int, input().split(\",\")))\ncheBasket = list(map(int, input().split(\",\")))\n\n# 设置储存输入的篮球序列的队列，这里要引入一个module\nfrom collections import deque\ntest = deque()\n# 我们最后要返回结果，里面包含字符“LEFT”和“RIGHT”\nres = \"\"\n\"\"\"\n我们首先要用队列去挨个读取放入的篮球序列，每放入一个篮球，就要跟取出篮球序列中的未被取出的篮球进行比较，如果不是，则读取\n下一个，如果是就要把它弹出去。这里注意：不仅放入篮球会改变左右两边的篮球序列号，弹出也会改变，\n而且未被取出的篮球序列一旦跟左右两边的篮球序号对上，我们就要看下一位是否跟新生成左右两边的篮球序号对应，\n这里很显然执行弹出操作时，还要继续往下进行检验。看来不得不用while循环了。,一旦用while循环，则必须要有\nindex号，我们要设立一个变量cheIndex来储存它。\n\"\"\"\ncheIndex = 0\n\nfor ch in teaBasket:\n    #首先把元素加入到队列中区\n    test.append(ch)\n    #其次要判断加入的元素是否跟未排出的篮球队列的第一个元素相符\n    '''\n    但是加入的元素是什么？是deque[-1],我让它去跟排出列表相比。那如果它是第一个且与排除队列中的元素\n    相等，这时，我就要从右边把deque排出元素，从右拿出，这是不行滴，因为如果放入的只有一个篮球的话，\n    必须要从左边拿出。\n    那么该怎么办呢？虽然我从右边放进一个新的篮球，但是我对比的时候，应该先让队列的左边第一个\n    元素去跟比，对吧？因为如果只进一个元素的话，第一个元素也是它，最后一个元素也是它，先让第一个\n    元素跟它比，就从左边拿出了。\n    还有一种情况就是队列中不止一个元素，有一个以上，那好像从左边跟未出列的元素进行对比，有点\n    费周章，因为肯定不是嘛，要不然怎么会新增加一个队列元素呢？但是这样能保证从左边拿出，而且\n    当拿出后，你还要往下一步看，是否我队列的左边和右边跟新出现的列表中的元素相等？这时再进入到\n    这个循环中，就可以继续对比了，所以要把整体设置成一个循环，先从左边看是否相等就不浪费了。\n    '''\n    # 这里还必须要考虑一种情况，就是如果队列已经为空，\n    # 那么再进入这个循环中，就没有test[0]了\n    # 所以必须加上判断队列是否为空\n    while test and cheIndex < len(teaBasket):# while保证它能一直判断\n        if test[0] == cheBasket[cheIndex]: # 本来是进行这个操作的，然后如果成功就继续判断，\n            test.popleft()              # 判断的内容还是跟进来一个新元素相同，所以就整体化\n            cheIndex += 1                # 为一个大循环\n            res += 'L'\n        elif test[-1] == cheBasket[cheIndex]:\n            test.pop()\n            cheIndex += 1\n            res += 'R'\n        else:\n            break\n\nif test:\n    print(\"NO\")\nelse:\n    print(res)\n```\n:::\n\n\n",
    "supporting": [
      "Queue_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}