[
  {
    "objectID": "Hash.html",
    "href": "Hash.html",
    "title": "哈希",
    "section": "",
    "text": "给你一个整数数组nums。如果任一值在数组中出现至少两次，返回true;如果数组中每个元素互不相同，返回false。\n示例一：\n\n输入：nums = [1,2,3,1]\n\n\n输出：true\n\n示例二：\n\n输入：nums = [1,2,3,4]\n\n\n输出：false\n\n示例三：\n\n输入：nums = [1,1,1,3,3,4,3,2,4,2]\n\n\n输出：true"
  },
  {
    "objectID": "Hash.html#lc217.-存在重复元素",
    "href": "Hash.html#lc217.-存在重复元素",
    "title": "4  哈希",
    "section": "4.1 LC217. 存在重复元素",
    "text": "4.1 LC217. 存在重复元素\n\n4.1.1 题目描述\n给你一个整数数组nums。如果任一值在数组中出现至少两次，返回true;如果数组中每个元素互不相同，返回false。\n示例一：\n\n输入：nums = [1,2,3,1]\n\n\n输出：true\n\n示例二：\n\n输入：nums = [1,2,3,4]\n\n\n输出：false\n\n示例三：\n\n输入：nums = [1,1,1,3,3,4,3,2,4,2]\n\n\n输出：true\n\n\n\n4.1.2 解题思路\n首先应该逐个读取输入的列表中的数据，并把它记录下来储存到一个数据结构中去，如果接下来我们读取到的数据跟数据结构中的数据重复，则说明原来输入的列表中至少有个元素出现了两次，而且只要一发现就可以直接返回true，特别迅速。\n问题是用什么数据结构来存储读取的数据，其实列表也行，元组也行。因为我们每读取一次数据后，都要和存储的数据结构进行对比，看看有没有重复的，那列表和元组都能执行这个功能。\n\n\n4.1.3 代码展示\n\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -&gt; bool:\n        #定义一个储存的数据结构\n        store = set()\n\n        #遍历传入的list\n        for ch in nums:\n            if ch in store:#查看是否有重复\n                return True#直接返回True，然后打断循环，结束任务\n            else:\n                store.add(ch)\n        # 如果遍历结束还没有返回bool值，就说明没有一个重复的，那么返回False就对了\n        return False"
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "5  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "References"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introduction",
    "section": "",
    "text": "Introduction\nThis is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "aa_env/Lib/site-packages/QtPy-2.4.1.dist-info/AUTHORS.html",
    "href": "aa_env/Lib/site-packages/QtPy-2.4.1.dist-info/AUTHORS.html",
    "title": "Authors",
    "section": "",
    "text": "pyqode.qt: Colin Duquesnoy ((ColinDuquesnoy?))\nspyderlib.qt: Pierre Raybaut ((PierreRaybaut?))\nqt-helpers: Thomas Robitaille ((astrofrog?))\n\n\n\n\n\nDaniel Althviz ((dalthviz?))\nCarlos Cordoba ((ccordoba12?))\nC.A.M. Gerlach ((CAM-Gerlach?))\nSpyder Development Team (Spyder-IDE)\n\n\n\n\n\nThe QtPy Contributors"
  },
  {
    "objectID": "aa_env/Lib/site-packages/QtPy-2.4.1.dist-info/AUTHORS.html#original-authors",
    "href": "aa_env/Lib/site-packages/QtPy-2.4.1.dist-info/AUTHORS.html#original-authors",
    "title": "Authors",
    "section": "",
    "text": "pyqode.qt: Colin Duquesnoy ((ColinDuquesnoy?))\nspyderlib.qt: Pierre Raybaut ((PierreRaybaut?))\nqt-helpers: Thomas Robitaille ((astrofrog?))"
  },
  {
    "objectID": "aa_env/Lib/site-packages/QtPy-2.4.1.dist-info/AUTHORS.html#current-maintainers",
    "href": "aa_env/Lib/site-packages/QtPy-2.4.1.dist-info/AUTHORS.html#current-maintainers",
    "title": "Authors",
    "section": "",
    "text": "Daniel Althviz ((dalthviz?))\nCarlos Cordoba ((ccordoba12?))\nC.A.M. Gerlach ((CAM-Gerlach?))\nSpyder Development Team (Spyder-IDE)"
  },
  {
    "objectID": "aa_env/Lib/site-packages/QtPy-2.4.1.dist-info/AUTHORS.html#contributors",
    "href": "aa_env/Lib/site-packages/QtPy-2.4.1.dist-info/AUTHORS.html#contributors",
    "title": "Authors",
    "section": "",
    "text": "The QtPy Contributors"
  },
  {
    "objectID": "aa_env/Lib/site-packages/idna-3.7.dist-info/LICENSE.html",
    "href": "aa_env/Lib/site-packages/idna-3.7.dist-info/LICENSE.html",
    "title": "",
    "section": "",
    "text": "BSD 3-Clause License\nCopyright (c) 2013-2024, Kim Davies and contributors. All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
  },
  {
    "objectID": "aa_env/Lib/site-packages/httpcore-1.0.5.dist-info/licenses/LICENSE.html",
    "href": "aa_env/Lib/site-packages/httpcore-1.0.5.dist-info/licenses/LICENSE.html",
    "title": "",
    "section": "",
    "text": "Copyright © 2020, Encode OSS Ltd. All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
  },
  {
    "objectID": "aa_env/Lib/site-packages/httpx-0.27.0.dist-info/licenses/LICENSE.html",
    "href": "aa_env/Lib/site-packages/httpx-0.27.0.dist-info/licenses/LICENSE.html",
    "title": "",
    "section": "",
    "text": "Copyright © 2019, Encode OSS Ltd. All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
  },
  {
    "objectID": "aa_env/Lib/site-packages/pyzmq-26.0.3.dist-info/licenses/LICENSE.html",
    "href": "aa_env/Lib/site-packages/pyzmq-26.0.3.dist-info/licenses/LICENSE.html",
    "title": "",
    "section": "",
    "text": "BSD 3-Clause License\nCopyright (c) 2009-2012, Brian Granger, Min Ragan-Kelley\nAll rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
  },
  {
    "objectID": "aa_env/Lib/site-packages/soupsieve-2.5.dist-info/licenses/LICENSE.html",
    "href": "aa_env/Lib/site-packages/soupsieve-2.5.dist-info/licenses/LICENSE.html",
    "title": "",
    "section": "",
    "text": "MIT License\nCopyright (c) 2018 - 2023 Isaac Muse isaacmuse@gmail.com\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "objectID": "Queue.html",
    "href": "Queue.html",
    "title": "队列",
    "section": "",
    "text": "题目描述\n幼儿园里有一个倒放的圆筒，它是一个线性结构，允许在桶的右边将篮球放入，可以在桶的左边和右边将篮球取出。每个篮球有单独的编号，老师可以连续放入一个或多个篮球，小朋友可以在桶左边或右边将篮球取出，当桶里只有一个篮球的情况下，必须从左边取出。\n如老师按顺序放入1、2、3、4、5共5个编号的篮球，那么小朋友可以依次取出的编号为1、2、3、4、5或者3、1、2、4、5编号的篮球，无法取出5、1、3、2、4编号的篮球。\n其中3、1、2、4、5的取出场景为：连续放入1、2、3号 -&gt; 从右边取出3号 -&gt; 从左边取出1号 -&gt; 从左边取出2号 -&gt; 放入4号 -&gt; 从左边取出4号 -&gt; 放入5号 -&gt; 从左边取出5号，简单起见，我们以L表示左,R表示右，此时的篮球的依次取出序列为RLLLL。\n输入描述\n每次输入包括一个测试用例：\n\n第一行的数字作为老师依次放入的篮球编号\n第二行的数字作为要检查是否能够按照放入顺序取出的篮球编号\n\n其中篮球编号用逗号进行分割。\n输出描述\n对于每个篮球的取出序列，如果确实可以获取，请打印出其按照左右方向的操作的取出顺序，如果无法获取则打印No\n\n1 &lt;= 篮球的编号， 篮球的个数 &lt;= 200\n篮球上的数字不重复\n输出的结果中LR的必须为大写\n\n示例\n\n输入：4,5,6,7,0,1,2\n\n\n输入: 6,4,0,1,2,5,7\n\n\n输出：RLRRRLL\n\n解题思路\n这道题的篮球一会从左边取，一会从右边取，很显然是一道以队列为存储对象的题目。我们先去一个一个用队列存储老师放进来的篮球，每放进一个，我们都要跟排出篮球的顺序中的首个序列号进行对比，如果一样就排出，如果不一样，就继续存储下一个篮球。但是如果恰巧一样，我们把它排出去了，就继续接收下一个篮球了吗？\n不是的，我们要看排出篮球后改变的队列排序，这时排出篮球序列也变化了。我们要让改变后的提取排序的第一项跟输入队列的左右两边进行对比，首先要跟左边进行对比，为什么呢？因为如果输入的篮球只剩下一个，而且恰巧这个时候，它又被排出去，很显然我们要从左边把它排出去，考虑到这个情况，我们很显然要以队列的最左边元素与输出数列的第一个进行比较。\n那如果比较成功了之后，我们就继续进行放入篮球吗？nono，我们再继续进行对比，而且这时的对比情况也是一样的。那我们是在每种情况下都输入一遍吗？不是，我们应该统一进行管理，用While循环进行整体遍历。而且我们注意到一个现象，就是无论是大的遍历还是小的遍历，输出数列的序列号总是要增长的。我们就以它的序列为遍历的标准，这时还要注意，万一队列里没了元素，我们就不能继续进入循环了，因为那样会导致指针冒出来，所以应该再加上队列是否为空，如果为空就跳过循环，去加元素到队列之中。\n当然，每次进行弹出操作是，我们都要在结果的字符串中加上“L”或者“R”。最后得到的队列如果为空，则说明所有篮球都可以按照顺序排出来，否则就排不出了，我们打印一个“NO”出来。\n\n# 这道题很明显要用队列来解决了，我们首先要接收两个字符串，把它们先变成list形式储存\nteaBasket = list(map(int, input().split(\",\")))\ncheBasket = list(map(int, input().split(\",\")))\n\n# 设置储存输入的篮球序列的队列，这里要引入一个module\nfrom collections import deque\ntest = deque()\n# 我们最后要返回结果，里面包含字符“LEFT”和“RIGHT”\nres = \"\"\n\"\"\"\n我们首先要用队列去挨个读取放入的篮球序列，每放入一个篮球，就要跟取出篮球序列中的未被取出的篮球进行比较，如果不是，则读取\n下一个，如果是就要把它弹出去。这里注意：不仅放入篮球会改变左右两边的篮球序列号，弹出也会改变，\n而且未被取出的篮球序列一旦跟左右两边的篮球序号对上，我们就要看下一位是否跟新生成左右两边的篮球序号对应，\n这里很显然执行弹出操作时，还要继续往下进行检验。看来不得不用while循环了。,一旦用while循环，则必须要有\nindex号，我们要设立一个变量cheIndex来储存它。\n\"\"\"\ncheIndex = 0\n\nfor ch in teaBasket:\n    #首先把元素加入到队列中区\n    test.append(ch)\n    #其次要判断加入的元素是否跟未排出的篮球队列的第一个元素相符\n    '''\n    但是加入的元素是什么？是deque[-1],我让它去跟排出列表相比。那如果它是第一个且与排除队列中的元素\n    相等，这时，我就要从右边把deque排出元素，从右拿出，这是不行滴，因为如果放入的只有一个篮球的话，\n    必须要从左边拿出。\n    那么该怎么办呢？虽然我从右边放进一个新的篮球，但是我对比的时候，应该先让队列的左边第一个\n    元素去跟比，对吧？因为如果只进一个元素的话，第一个元素也是它，最后一个元素也是它，先让第一个\n    元素跟它比，就从左边拿出了。\n    还有一种情况就是队列中不止一个元素，有一个以上，那好像从左边跟未出列的元素进行对比，有点\n    费周章，因为肯定不是嘛，要不然怎么会新增加一个队列元素呢？但是这样能保证从左边拿出，而且\n    当拿出后，你还要往下一步看，是否我队列的左边和右边跟新出现的列表中的元素相等？这时再进入到\n    这个循环中，就可以继续对比了，所以要把整体设置成一个循环，先从左边看是否相等就不浪费了。\n    '''\n    # 这里还必须要考虑一种情况，就是如果队列已经为空，\n    # 那么再进入这个循环中，就没有test[0]了\n    # 所以必须加上判断队列是否为空\n    while test and cheIndex &lt; len(teaBasket):# while保证它能一直判断\n        if test[0] == cheBasket[cheIndex]: # 本来是进行这个操作的，然后如果成功就继续判断，\n            test.popleft()              # 判断的内容还是跟进来一个新元素相同，所以就整体化\n            cheIndex += 1                # 为一个大循环\n            res += 'L'\n        elif test[-1] == cheBasket[cheIndex]:\n            test.pop()\n            cheIndex += 1\n            res += 'R'\n        else:\n            break\n\nif test:\n    print(\"NO\")\nelse:\n    print(res)"
  },
  {
    "objectID": "Queue.html#华为od真题",
    "href": "Queue.html#华为od真题",
    "title": "3  队列",
    "section": "3.1 华为OD真题",
    "text": "3.1 华为OD真题\n\n3.1.1 【队列】2024C-篮球游戏\n题目描述\n幼儿园里有一个倒放的圆筒，它是一个线性结构，允许在桶的右边将篮球放入，可以在桶的左边和右边将篮球取出。每个篮球有单独的编号，老师可以连续放入一个或多个篮球，小朋友可以在桶左边或右边将篮球取出，当桶里只有一个篮球的情况下，必须从左边取出。\n如老师按顺序放入1、2、3、4、5共5个编号的篮球，那么小朋友可以依次取出的编号为1、2、3、4、5或者3、1、2、4、5编号的篮球，无法取出5、1、3、2、4编号的篮球。\n其中3、1、2、4、5的取出场景为：连续放入1、2、3号 -&gt; 从右边取出3号 -&gt; 从左边取出1号 -&gt; 从左边取出2号 -&gt; 放入4号 -&gt; 从左边取出4号 -&gt; 放入5号 -&gt; 从左边取出5号，简单起见，我们以L表示左,R表示右，此时的篮球的依次取出序列为RLLLL。\n输入描述\n每次输入包括一个测试用例：\n\n第一行的数字作为老师依次放入的篮球编号\n第二行的数字作为要检查是否能够按照放入顺序取出的篮球编号\n\n其中篮球编号用逗号进行分割。\n输出描述\n对于每个篮球的取出序列，如果确实可以获取，请打印出其按照左右方向的操作的取出顺序，如果无法获取则打印No\n\n1 &lt;= 篮球的编号， 篮球的个数 &lt;= 200\n篮球上的数字不重复\n输出的结果中LR的必须为大写\n\n示例\n\n输入：4,5,6,7,0,1,2\n\n\n输入: 6,4,0,1,2,5,7\n\n\n输出：RLRRRLL\n\n解题思路\n这道题的篮球一会从左边取，一会从右边取，很显然是一道以队列为存储对象的题目。我们先去一个一个用队列存储老师放进来的篮球，每放进一个，我们都要跟排出篮球的顺序中的首个序列号进行对比，如果一样就排出，如果不一样，就继续存储下一个篮球。但是如果恰巧一样，我们把它排出去了，就继续接收下一个篮球了吗？\n不是的，我们要看排出篮球后改变的队列排序，这时排出篮球序列也变化了。我们要让改变后的提取排序的第一项跟输入队列的左右两边进行对比，首先要跟左边进行对比，为什么呢？因为如果输入的篮球只剩下一个，而且恰巧这个时候，它又被排出去，很显然我们要从左边把它排出去，考虑到这个情况，我们很显然要以队列的最左边元素与输出数列的第一个进行比较。\n那如果比较成功了之后，我们就继续进行放入篮球吗？nono，我们再继续进行对比，而且这时的对比情况也是一样的。那我们是在每种情况下都输入一遍吗？不是，我们应该统一进行管理，用While循环进行整体遍历。而且我们注意到一个现象，就是无论是大的遍历还是小的遍历，输出数列的序列号总是要增长的。我们就以它的序列为遍历的标准，这时还要注意，万一队列里没了元素，我们就不能继续进入循环了，因为那样会导致指针冒出来，所以应该再加上队列是否为空，如果为空就跳过循环，去加元素到队列之中。\n当然，每次进行弹出操作是，我们都要在结果的字符串中加上“L”或者“R”。最后得到的队列如果为空，则说明所有篮球都可以按照顺序排出来，否则就排不出了，我们打印一个“NO”出来。\n\n# 这道题很明显要用队列来解决了，我们首先要接收两个字符串，把它们先变成list形式储存\nteaBasket = list(map(int, input().split(\",\")))\ncheBasket = list(map(int, input().split(\",\")))\n\n# 设置储存输入的篮球序列的队列，这里要引入一个module\nfrom collections import deque\ntest = deque()\n# 我们最后要返回结果，里面包含字符“LEFT”和“RIGHT”\nres = \"\"\n\"\"\"\n我们首先要用队列去挨个读取放入的篮球序列，每放入一个篮球，就要跟取出篮球序列中的未被取出的篮球进行比较，如果不是，则读取\n下一个，如果是就要把它弹出去。这里注意：不仅放入篮球会改变左右两边的篮球序列号，弹出也会改变，\n而且未被取出的篮球序列一旦跟左右两边的篮球序号对上，我们就要看下一位是否跟新生成左右两边的篮球序号对应，\n这里很显然执行弹出操作时，还要继续往下进行检验。看来不得不用while循环了。,一旦用while循环，则必须要有\nindex号，我们要设立一个变量cheIndex来储存它。\n\"\"\"\ncheIndex = 0\n\nfor ch in teaBasket:\n    #首先把元素加入到队列中区\n    test.append(ch)\n    #其次要判断加入的元素是否跟未排出的篮球队列的第一个元素相符\n    '''\n    但是加入的元素是什么？是deque[-1],我让它去跟排出列表相比。那如果它是第一个且与排除队列中的元素\n    相等，这时，我就要从右边把deque排出元素，从右拿出，这是不行滴，因为如果放入的只有一个篮球的话，\n    必须要从左边拿出。\n    那么该怎么办呢？虽然我从右边放进一个新的篮球，但是我对比的时候，应该先让队列的左边第一个\n    元素去跟比，对吧？因为如果只进一个元素的话，第一个元素也是它，最后一个元素也是它，先让第一个\n    元素跟它比，就从左边拿出了。\n    还有一种情况就是队列中不止一个元素，有一个以上，那好像从左边跟未出列的元素进行对比，有点\n    费周章，因为肯定不是嘛，要不然怎么会新增加一个队列元素呢？但是这样能保证从左边拿出，而且\n    当拿出后，你还要往下一步看，是否我队列的左边和右边跟新出现的列表中的元素相等？这时再进入到\n    这个循环中，就可以继续对比了，所以要把整体设置成一个循环，先从左边看是否相等就不浪费了。\n    '''\n    # 这里还必须要考虑一种情况，就是如果队列已经为空，\n    # 那么再进入这个循环中，就没有test[0]了\n    # 所以必须加上判断队列是否为空\n    while test and cheIndex &lt; len(teaBasket):# while保证它能一直判断\n        if test[0] == cheBasket[cheIndex]: # 本来是进行这个操作的，然后如果成功就继续判断，\n            test.popleft()              # 判断的内容还是跟进来一个新元素相同，所以就整体化\n            cheIndex += 1                # 为一个大循环\n            res += 'L'\n        elif test[-1] == cheBasket[cheIndex]:\n            test.pop()\n            cheIndex += 1\n            res += 'R'\n        else:\n            break\n\nif test:\n    print(\"NO\")\nelse:\n    print(res)"
  },
  {
    "objectID": "Stack.html",
    "href": "Stack.html",
    "title": "栈",
    "section": "",
    "text": "题目描述\n给定用户密码输入流 input，输入流中字符&lt;表示退格，可以清除前一个输入的字符，请你编写程序，输出最终得到的密码字符，并判断密码是否满足如下的密码安全要求。 密码安全要求如下：\n\n密码长度&gt;=8;\n密码至少需要包含 1 个大写字母;\n密码至少需要包含 1 个小写字母;\n密码至少需要包含 1 个数字;\n密码至少需要包含 1 个字母和数字以外的非空白特殊字符\n\n注意空串退格后仍然为空串，且用户输入的字符串不包含&lt;字符和空白字符。\n输入描述\n用一行字符串表示输入的用户数据，输入的字符串中’&lt;’字符标识退格，用户输入的字符串不包含空白字符，例如：ABC&lt;c89%000&lt;\n输出描述\n输出经过程序处理后，输出的实际密码字符串，并输出改密码字符串是否满足密码安全要求。两者间由’,’分隔， 例如：ABc89%00,true\n示例\n\n输入：ABC&lt;c89%000&lt;\n\n\n输出：ABc89%00,true\n\n解题思路\n我认为这道题是需要考虑两种特殊情况，第一种是输入出现了空格，第二种是输入出现了&lt;。如果是第一种情况，直接略过即可，要是第二种情况就比较复杂，我们需要把前面一个 存入的答案字符删去，而且如果前面没有答案字符的话，就略过。这意味着我们每次读取输入的字符串的内容，并不是存入即好，有些元素是要被抛弃掉的，而且那些被抛弃掉的元素 都是刚刚放入的或者是刚刚放入不久的。\n这里就很容易想到用栈的方式，当遇到除了&lt;和空格的字符时，我们把它存入栈中。当遇到&lt;时，我们把栈中的最上面的元素弹出来（这里还要考虑一下栈为空的情况），遍历之后得到 的Stack是一个list。之前我还想如何把Stack中的数据按照字符串的形式表现出来，本来想的是也是在栈中取数据的方式，从上面一个一个取，后来想到，它就是一个list（），我可以直接 按照list的顺序通过\"\".join(list)的形式变成字符串。\n最终还是要看看密码的字符串是否符合规则，这里用了any()函数来判断五条规定是否成立，然后返回密码内容和判断对错的情况，最后还是有一些小插曲，在print()操作中有一些小细节 要注意一下。\n\n# 首先把字符串输入进来，用变量ex储存\nex = input()\n\n#我们需要返回密码是否有效，所以要设置一个bool的变量\n\nisError = False\n\n# 我们要用一个栈来储存输入的字符串内容，但是不应该包含‘&lt;’，所以每次一旦遇到‘&lt;’，就该停下来看看\nStack = list()\n\n# 开始进入一个循环，逐个读取字符串的内容\nfor ch in ex:\n  # 目前看来字符串的内容就分为两类，一类是‘&lt;’，另一类是其他符号\n  if ch == '&lt;':\n    # 这里注意一下，如果栈中没有数据了，我们不能弹出最上面的数据，所以一定要看看栈是否为空\n    if Stack:\n      Stack.pop()\n  elif ch == \" \": # 如果是空白字符，不能算入密码内\n    continue\n\n  else:# 这是其他符号的情况\n    Stack.append(ch)\n# 结束遍历之后，我们会得到一个list，这个按照list从0到n-1的顺序就是密码的内容了，现在我们需要把密码展现出来并且看看它是否合理\n\n# 首先来看看它是否长度大于等于8\nflag1 = len(Stack) &gt;= 8\n\n# 然后来看栈里面是否有大写字母的存在，如果有的话，就返回对，如果一个都没有的话就返回错，这里用到any()函数\n# any函数是内置函数（就是Python自带的函数），用于判断列表、远足等结构中是否至少有一个元素为真。如果都不是真的话，返回否；至少有一个为真的话，返回是。\n\nflag2 = any(x.isupper() for x in Stack)  # 这里注意括号里的整体是一个list的生成器，其中每一个元素都是bool类型\n\n#检测是否有小写字母\nflag3 = any(x.islower() for x in Stack)\n\n#检测是否有数字\n\nflag4 = any(x.isdigit() for x in Stack)\n\n# 检测是否有除了空白字符外的特殊字符\n\nflag5 = any( (not x.isalpha()) and (not x.isdigit()) for x in Stack)\n\n# 如果五种情况都对的话，那么返回的情况是对，否则是错\n\nisError = not (flag1 and flag2 and flag3 and flag4 and flag5)\n\n#用`\"\".join(list)`把列表里面的每个元素合起来变成一个字符串\n\nprint(\"\".join(Stack)+\",\"+('true' if not isError else 'false') )\n# 最后一行操作还挺复杂的，如果最后的if和else不加括号的话，测试结果只能对一半，你猜猜为什么？\n\n\n\n\n题目描述\n已知火星人使用的运算符号为#、$，他们与地球人的等价公式如下：\n\nx#y = 4*x + 3*y + 2\nx$y = 2*x + y + 3\n\n其中x与y是无符号整数，地球人公式按照C语言规则进行计算，火星人公式中的#符优先级高于$，相同的运算符按从左到右的顺序计算。\n输入描述\n火星人字符串表达式结尾不带回车换行\n字符串为仅有无符号整数和操作符组成的计算表达式\n\n用例保证字符串中操作数与操作符之间没有任何分隔符\n用例保证操作数取值范围为32位无符号整数\n保证输入以及计算结果不会出现整型溢出\n保证输入的字符串为合法的求值报文，例如：123#4&576$78\n保证不会出现非法的求值报文\n\n#4$5这种缺少操作数\n4$5#这种缺少操作数\n4#$5这种缺少操作数\n4 $5有空格\n3+4-5*6/7有其他操作符\n12345678987654321$5432132位整数溢出\n\n\n输出描述\n根据火星人字符串输出计算结果，结尾不带回车换行\n实例\n\n输入：7#6$5#12\n\n\n输出：157\n\n\n说明：7#6$5#12 = (4*7 + 3*6 + 2)$5#12 = 48$(4 * 5 + 3 * 12 + 2) = 48$58 = 2 * 48 + 58 + 3 = 157\n\n解题思路\n这道题看似是一道计算题，定义了两种运算，其中的#运算比$运算优先级更高，而且也是从左往右计算，这特别像乘法与加法运算一样。按照人类的计算来讲，就是挨个读取输入的数据和运算符号，并且及时计算。但是及时挨个输入，我也不能一遇到数据就可以进行计算，万一后面的计算符号优先等级更高，我就必须先把前面算得的数据放起来，开始进行后面的数据计算，然后再把整体从左往右进行计算。\n通过上面叙述，这里注意到题目的特性，既要读取数据，又要计算数据，有时还要搁置数据，并且数据不会被搁置的太长。这很显然要用栈来操作，如果被处理的数据总是那些很早之前就存入进去的，我们就要用队列来实现。\n对于读取数据好说，看到数据就记下，重要的是什么时候把它放到栈里面去呢？有两个选择：\n\n完整地读完一个数据，就存储到栈里面去\n等遇到计算符号时，把数据存储到栈里面去\n\n如果是第一种情况，我们不仅要读取数据，还要看数据下一位是否是运算符号，如果是运算符号，我们就停止输入数字，把所得到的数字进行整合化成一个数据，然后把它存到栈中去。\n如果是第二种情况，我们不用考虑已经读取到的字符是否真的构成一个完整的数据，只要我遇到了一个运算字符就说明前面所有的输入数字字符构成一个数据，那么当我遇到数字字符的时候，只需把它记下，再加上前面的数据*10即可。\n貌似第二种方式更加便捷一些，因为如果是第一种方式，我要提前预判后面的操作，读取数据时不能用for ch in s的操作，只能是 for i in range(0,len - 1)，这样也不是不行，但是肯定不如前面那样逻辑清楚，所以一般我是不愿意那样做的。第二种方式不用提前预判，这在逻辑和代码上减缓了我们的压力，谁都不愿意循环中套一个循环。\n这样压力就转移到了遇到计算字符的条件下该执行什么样的操作，这里还有两种情况：\n\n遇到低优先级计算符\n遇到高优先级计算符\n\n如果是第二种情况，毫无疑问马上进行计算，把栈中最上面的两个元素弹出，然后再把计算的结果放入栈中。但是别忘了运算符号在要计算了两个数据中间，所以还缺一个数据不能进行计算。要等到下一个数据进栈后，马上进行计算，下一个数据什么时候进栈呢？就是遇见下一个运算符，这里注意不管是什么等级的运算符，我们都要去判断，除了把数据进栈后，是否还要进行运算。\n当第一种情况遇见低等级的计算符时，有下面两种情况：\n\n4#2&4\n4$2$4\n\n第一种情况，很显然我们要马上对4和2进行计算。第二种情况，不用进行计算直接存储数据即可。如何实现这样的操作呢？我们就要在全局中设立一个变量记录是否上次遇见的计算符是高等级的计算符，如果是就计算，如果不是就不计算。\n当进行完循环的时候，我们有个bug，就是最后一个数字我们无法让它存入栈中，而题目中说结尾没有任何其他字符，而我们让数据进栈并且计算只有一种情况，那就是遇见非数字的情况，那么我们可以人为的改变输入的字符串，在最后我们可以加一个“ ”空格进去，这时读取玩最后一个数字的时候，接着读取到了空格，这时就可以针对最后一个数据进行存储计算了，最终得到了进行完最高等级运算的数据列表。\n然后要按照列表里的数据，按照顺序一个挨着一个进行低等级计算。肯定要进行遍历，但是不能一上来就从第一个开始遍历。我们先提取第一个数据，然后从第二个数据开始遍历，首先跟第二个数据跟第一个数据进行计算，得出来的结果放到变量中，遍历第三个时，跟这个变量进行计算，得出来的结果再放入到同样的变量中，最终得出来的结果就是按照顺序计算低等级运算的。\n\n# 读取字符串\ns = input()\ns = s + \" \"\n'''\n这里有两个运算，无论是什么逻辑解决这道题，我们都需要大量应用这两个运算，如果每次\n都按照题目的运算顺序去写出来的话，太过麻烦，所以我们要设立两个运算函数，这样如果\n要进行运算时，直接调用即可。\n'''\ndef cal_well(x,y):\n  return 4 * x + 3 * y + 2\n\ndef cal_dollor(x,y):\n  return 2 * x + y + 3\n\n'''\n这里我们思考一下，对于进行例如7#6$5#12这样的运算，需要对数据进行存储，需要我们搞清楚优先级顺序。\n按照正常逻辑，我们应该先进行#运算，然后在进行$运算。也就是说我们不能直接把所有的数据直接存储起\n来，我们首先应该计算完#运算之后，把所有的数据存储起来，在按照顺序把数据进行$运算。那现在的问题\n就是如何计算完#之后，把数据按照顺序存储起来？很明显，我们要按照栈的方式进行数据存储，当遇到#的\n时候，把两个数据进行运算得到的结果再储存到栈中，这样能保持栈中的元素是进行#运算之后的元素，遇到\n$时，什么都不干，继续存储$之后的数字（因为我们只计算#），最终得到的栈的元素就是我们进行完#运算\n之后要进行$的数据。\n'''\n\n# 构建存储数据的栈\nstore = list()\n\nnum = 0 # 用于储存数据\n\nmeetWell = False  # 是否遇到#号\n# 遍历字符串\nfor ch in s:\n  if ch.isdigit():\n    #数字有可能是两位数或三位数以上，所以不能直接存入栈中，我们要让之前的数据乘上十倍再加现在的数\n    num = num * 10 + int(ch)\n  else:# 这里是#和$的情况\n\n    #首先遇到这个最高优先级的计算符号，我们要把之前的数据存储起来,并且要把单个数据存储num归零\n    #这样好进行下一个数据的存储\n    store.append(num)\n    num = 0\n    # 如果是进行'4 # 3 $ 5'的计算，我们到这步只是把4存储了起来，到3的时候必须让4跟3进行#运算后得到的数据\n    # 存储到栈中\n    '''\n    现在面临两个选择，第一个选择是在遇到#号时，直接进行计算，但是下一个数字我们还没有把它存入到栈中；\n    第二个选择是等到下一个数字时，我们把栈中最上面的元素弹出来，进行计算然后放到栈中。\n    这里我选择第一个选择，为什么呢？因为如果执行第二个选择的话，就要在ch.isdigit()这里去进行进栈操作，\n    这样的话遇到符号要考虑进栈，遇见数字还要考虑进栈。逻辑上，包括代码上都更加复杂了。\n    那就要在遇见算数符号时，都要考虑一下是否进行计算，很显然，第一次遇见算数符号#时不计算，第二次遇见算数\n    符号（不管是否为#）时就要计算了，所以条件我们就不能只是#，应该是‘#$’，这里就直接除了数字之外的else即可。\n    另外要注意，我们这里设置一个变量记录是否遇到了#号，我们把这个变量是否改变的代码放在执行计算的后面，这样\n    第一次执行else里的代码时，我们没遇到#，就不执行，然后在最后把meetweel改为True，等下次遇见计算符号时，就\n    可以计算了，然后再看遇见的符号是不是#，如果是的话，就改meetWeel为True，如果不是就改为Fasle。这样也就避\n    免了，遇见很多次$符号时，还计算的错误情况，保证只进行#运算。\n    '''\n    if meetWell:\n      y = store.pop()\n      x = store.pop()\n      store.append(cal_well(x,y))\n\n    if ch == '#':\n      meetWell = True\n    else:\n      meetWell = False\n\n# 题目中说输入的字符串结尾最后一个数字后面啥都没有，也就意味着我们的计算逻辑是有缺陷的，\n# 最后一个数字没有经过我们的计算，甚至连进入栈的资格都没有。要想让最后一个数字被计算并且\n# 能进栈，必须在字符串内容读取完了之后，还要再读取一个非数字和计算符号的字符，这样就会\n# 进入到else的状态中，把最后一个数字输入进栈，并且进行判断是否计算，才能得到最终的结果。\n\n# 接下来就要去计算$了\n# 先把栈中的第一个元素记录下来，通过变量res进行存储，然后挨个循环列表跟res进行$计算，\n# 再把结果记为res，最终就会得出答案\nres = store[0]\nfor i in store[1:]:\n  res = cal_dollor(res,i)\n\nprint(res)"
  },
  {
    "objectID": "Stack.html#华为od真题",
    "href": "Stack.html#华为od真题",
    "title": "2  栈",
    "section": "2.1 华为OD真题",
    "text": "2.1 华为OD真题\n\n2.1.1 【栈】2024D-密码输入检测\n题目描述\n给定用户密码输入流 input，输入流中字符&lt;表示退格，可以清除前一个输入的字符，请你编写程序，输出最终得到的密码字符，并判断密码是否满足如下的密码安全要求。 密码安全要求如下：\n\n密码长度&gt;=8;\n密码至少需要包含 1 个大写字母;\n密码至少需要包含 1 个小写字母;\n密码至少需要包含 1 个数字;\n密码至少需要包含 1 个字母和数字以外的非空白特殊字符\n\n注意空串退格后仍然为空串，且用户输入的字符串不包含&lt;字符和空白字符。\n输入描述\n用一行字符串表示输入的用户数据，输入的字符串中’&lt;’字符标识退格，用户输入的字符串不包含空白字符，例如：ABC&lt;c89%000&lt;\n输出描述\n输出经过程序处理后，输出的实际密码字符串，并输出改密码字符串是否满足密码安全要求。两者间由’,’分隔， 例如：ABc89%00,true\n示例\n\n输入：ABC&lt;c89%000&lt;\n\n\n输出：ABc89%00,true\n\n解题思路\n我认为这道题是需要考虑两种特殊情况，第一种是输入出现了空格，第二种是输入出现了&lt;。如果是第一种情况，直接略过即可，要是第二种情况就比较复杂，我们需要把前面一个 存入的答案字符删去，而且如果前面没有答案字符的话，就略过。这意味着我们每次读取输入的字符串的内容，并不是存入即好，有些元素是要被抛弃掉的，而且那些被抛弃掉的元素 都是刚刚放入的或者是刚刚放入不久的。\n这里就很容易想到用栈的方式，当遇到除了&lt;和空格的字符时，我们把它存入栈中。当遇到&lt;时，我们把栈中的最上面的元素弹出来（这里还要考虑一下栈为空的情况），遍历之后得到 的Stack是一个list。之前我还想如何把Stack中的数据按照字符串的形式表现出来，本来想的是也是在栈中取数据的方式，从上面一个一个取，后来想到，它就是一个list（），我可以直接 按照list的顺序通过\"\".join(list)的形式变成字符串。\n最终还是要看看密码的字符串是否符合规则，这里用了any()函数来判断五条规定是否成立，然后返回密码内容和判断对错的情况，最后还是有一些小插曲，在print()操作中有一些小细节 要注意一下。\n\n# 首先把字符串输入进来，用变量ex储存\nex = input()\n\n#我们需要返回密码是否有效，所以要设置一个bool的变量\n\nisError = False\n\n# 我们要用一个栈来储存输入的字符串内容，但是不应该包含‘&lt;’，所以每次一旦遇到‘&lt;’，就该停下来看看\nStack = list()\n\n# 开始进入一个循环，逐个读取字符串的内容\nfor ch in ex:\n  # 目前看来字符串的内容就分为两类，一类是‘&lt;’，另一类是其他符号\n  if ch == '&lt;':\n    # 这里注意一下，如果栈中没有数据了，我们不能弹出最上面的数据，所以一定要看看栈是否为空\n    if Stack:\n      Stack.pop()\n  elif ch == \" \": # 如果是空白字符，不能算入密码内\n    continue\n\n  else:# 这是其他符号的情况\n    Stack.append(ch)\n# 结束遍历之后，我们会得到一个list，这个按照list从0到n-1的顺序就是密码的内容了，现在我们需要把密码展现出来并且看看它是否合理\n\n# 首先来看看它是否长度大于等于8\nflag1 = len(Stack) &gt;= 8\n\n# 然后来看栈里面是否有大写字母的存在，如果有的话，就返回对，如果一个都没有的话就返回错，这里用到any()函数\n# any函数是内置函数（就是Python自带的函数），用于判断列表、远足等结构中是否至少有一个元素为真。如果都不是真的话，返回否；至少有一个为真的话，返回是。\n\nflag2 = any(x.isupper() for x in Stack)  # 这里注意括号里的整体是一个list的生成器，其中每一个元素都是bool类型\n\n#检测是否有小写字母\nflag3 = any(x.islower() for x in Stack)\n\n#检测是否有数字\n\nflag4 = any(x.isdigit() for x in Stack)\n\n# 检测是否有除了空白字符外的特殊字符\n\nflag5 = any( (not x.isalpha()) and (not x.isdigit()) for x in Stack)\n\n# 如果五种情况都对的话，那么返回的情况是对，否则是错\n\nisError = not (flag1 and flag2 and flag3 and flag4 and flag5)\n\n#用`\"\".join(list)`把列表里面的每个元素合起来变成一个字符串\n\nprint(\"\".join(Stack)+\",\"+('true' if not isError else 'false') )\n# 最后一行操作还挺复杂的，如果最后的if和else不加括号的话，测试结果只能对一半，你猜猜为什么？\n\n\n\n2.1.2 【栈】2023C-火星文计算2\n题目描述\n已知火星人使用的运算符号为#、$，他们与地球人的等价公式如下：\n\nx#y = 4*x + 3*y + 2\nx$y = 2*x + y + 3\n\n其中x与y是无符号整数，地球人公式按照C语言规则进行计算，火星人公式中的#符优先级高于$，相同的运算符按从左到右的顺序计算。\n输入描述\n火星人字符串表达式结尾不带回车换行\n字符串为仅有无符号整数和操作符组成的计算表达式\n\n用例保证字符串中操作数与操作符之间没有任何分隔符\n用例保证操作数取值范围为32位无符号整数\n保证输入以及计算结果不会出现整型溢出\n保证输入的字符串为合法的求值报文，例如：123#4&576$78\n保证不会出现非法的求值报文\n\n#4$5这种缺少操作数\n4$5#这种缺少操作数\n4#$5这种缺少操作数\n4 $5有空格\n3+4-5*6/7有其他操作符\n12345678987654321$5432132位整数溢出\n\n\n输出描述\n根据火星人字符串输出计算结果，结尾不带回车换行\n实例\n\n输入：7#6$5#12\n\n\n输出：157\n\n\n说明：7#6$5#12 = (4*7 + 3*6 + 2)$5#12 = 48$(4 * 5 + 3 * 12 + 2) = 48$58 = 2 * 48 + 58 + 3 = 157\n\n解题思路\n这道题看似是一道计算题，定义了两种运算，其中的#运算比$运算优先级更高，而且也是从左往右计算，这特别像乘法与加法运算一样。按照人类的计算来讲，就是挨个读取输入的数据和运算符号，并且及时计算。但是及时挨个输入，我也不能一遇到数据就可以进行计算，万一后面的计算符号优先等级更高，我就必须先把前面算得的数据放起来，开始进行后面的数据计算，然后再把整体从左往右进行计算。\n通过上面叙述，这里注意到题目的特性，既要读取数据，又要计算数据，有时还要搁置数据，并且数据不会被搁置的太长。这很显然要用栈来操作，如果被处理的数据总是那些很早之前就存入进去的，我们就要用队列来实现。\n对于读取数据好说，看到数据就记下，重要的是什么时候把它放到栈里面去呢？有两个选择：\n\n完整地读完一个数据，就存储到栈里面去\n等遇到计算符号时，把数据存储到栈里面去\n\n如果是第一种情况，我们不仅要读取数据，还要看数据下一位是否是运算符号，如果是运算符号，我们就停止输入数字，把所得到的数字进行整合化成一个数据，然后把它存到栈中去。\n如果是第二种情况，我们不用考虑已经读取到的字符是否真的构成一个完整的数据，只要我遇到了一个运算字符就说明前面所有的输入数字字符构成一个数据，那么当我遇到数字字符的时候，只需把它记下，再加上前面的数据*10即可。\n貌似第二种方式更加便捷一些，因为如果是第一种方式，我要提前预判后面的操作，读取数据时不能用for ch in s的操作，只能是 for i in range(0,len - 1)，这样也不是不行，但是肯定不如前面那样逻辑清楚，所以一般我是不愿意那样做的。第二种方式不用提前预判，这在逻辑和代码上减缓了我们的压力，谁都不愿意循环中套一个循环。\n这样压力就转移到了遇到计算字符的条件下该执行什么样的操作，这里还有两种情况：\n\n遇到低优先级计算符\n遇到高优先级计算符\n\n如果是第二种情况，毫无疑问马上进行计算，把栈中最上面的两个元素弹出，然后再把计算的结果放入栈中。但是别忘了运算符号在要计算了两个数据中间，所以还缺一个数据不能进行计算。要等到下一个数据进栈后，马上进行计算，下一个数据什么时候进栈呢？就是遇见下一个运算符，这里注意不管是什么等级的运算符，我们都要去判断，除了把数据进栈后，是否还要进行运算。\n当第一种情况遇见低等级的计算符时，有下面两种情况：\n\n4#2&4\n4$2$4\n\n第一种情况，很显然我们要马上对4和2进行计算。第二种情况，不用进行计算直接存储数据即可。如何实现这样的操作呢？我们就要在全局中设立一个变量记录是否上次遇见的计算符是高等级的计算符，如果是就计算，如果不是就不计算。\n当进行完循环的时候，我们有个bug，就是最后一个数字我们无法让它存入栈中，而题目中说结尾没有任何其他字符，而我们让数据进栈并且计算只有一种情况，那就是遇见非数字的情况，那么我们可以人为的改变输入的字符串，在最后我们可以加一个“ ”空格进去，这时读取玩最后一个数字的时候，接着读取到了空格，这时就可以针对最后一个数据进行存储计算了，最终得到了进行完最高等级运算的数据列表。\n然后要按照列表里的数据，按照顺序一个挨着一个进行低等级计算。肯定要进行遍历，但是不能一上来就从第一个开始遍历。我们先提取第一个数据，然后从第二个数据开始遍历，首先跟第二个数据跟第一个数据进行计算，得出来的结果放到变量中，遍历第三个时，跟这个变量进行计算，得出来的结果再放入到同样的变量中，最终得出来的结果就是按照顺序计算低等级运算的。\n\n# 读取字符串\ns = input()\ns = s + \" \"\n'''\n这里有两个运算，无论是什么逻辑解决这道题，我们都需要大量应用这两个运算，如果每次\n都按照题目的运算顺序去写出来的话，太过麻烦，所以我们要设立两个运算函数，这样如果\n要进行运算时，直接调用即可。\n'''\ndef cal_well(x,y):\n  return 4 * x + 3 * y + 2\n\ndef cal_dollor(x,y):\n  return 2 * x + y + 3\n\n'''\n这里我们思考一下，对于进行例如7#6$5#12这样的运算，需要对数据进行存储，需要我们搞清楚优先级顺序。\n按照正常逻辑，我们应该先进行#运算，然后在进行$运算。也就是说我们不能直接把所有的数据直接存储起\n来，我们首先应该计算完#运算之后，把所有的数据存储起来，在按照顺序把数据进行$运算。那现在的问题\n就是如何计算完#之后，把数据按照顺序存储起来？很明显，我们要按照栈的方式进行数据存储，当遇到#的\n时候，把两个数据进行运算得到的结果再储存到栈中，这样能保持栈中的元素是进行#运算之后的元素，遇到\n$时，什么都不干，继续存储$之后的数字（因为我们只计算#），最终得到的栈的元素就是我们进行完#运算\n之后要进行$的数据。\n'''\n\n# 构建存储数据的栈\nstore = list()\n\nnum = 0 # 用于储存数据\n\nmeetWell = False  # 是否遇到#号\n# 遍历字符串\nfor ch in s:\n  if ch.isdigit():\n    #数字有可能是两位数或三位数以上，所以不能直接存入栈中，我们要让之前的数据乘上十倍再加现在的数\n    num = num * 10 + int(ch)\n  else:# 这里是#和$的情况\n\n    #首先遇到这个最高优先级的计算符号，我们要把之前的数据存储起来,并且要把单个数据存储num归零\n    #这样好进行下一个数据的存储\n    store.append(num)\n    num = 0\n    # 如果是进行'4 # 3 $ 5'的计算，我们到这步只是把4存储了起来，到3的时候必须让4跟3进行#运算后得到的数据\n    # 存储到栈中\n    '''\n    现在面临两个选择，第一个选择是在遇到#号时，直接进行计算，但是下一个数字我们还没有把它存入到栈中；\n    第二个选择是等到下一个数字时，我们把栈中最上面的元素弹出来，进行计算然后放到栈中。\n    这里我选择第一个选择，为什么呢？因为如果执行第二个选择的话，就要在ch.isdigit()这里去进行进栈操作，\n    这样的话遇到符号要考虑进栈，遇见数字还要考虑进栈。逻辑上，包括代码上都更加复杂了。\n    那就要在遇见算数符号时，都要考虑一下是否进行计算，很显然，第一次遇见算数符号#时不计算，第二次遇见算数\n    符号（不管是否为#）时就要计算了，所以条件我们就不能只是#，应该是‘#$’，这里就直接除了数字之外的else即可。\n    另外要注意，我们这里设置一个变量记录是否遇到了#号，我们把这个变量是否改变的代码放在执行计算的后面，这样\n    第一次执行else里的代码时，我们没遇到#，就不执行，然后在最后把meetweel改为True，等下次遇见计算符号时，就\n    可以计算了，然后再看遇见的符号是不是#，如果是的话，就改meetWeel为True，如果不是就改为Fasle。这样也就避\n    免了，遇见很多次$符号时，还计算的错误情况，保证只进行#运算。\n    '''\n    if meetWell:\n      y = store.pop()\n      x = store.pop()\n      store.append(cal_well(x,y))\n\n    if ch == '#':\n      meetWell = True\n    else:\n      meetWell = False\n\n# 题目中说输入的字符串结尾最后一个数字后面啥都没有，也就意味着我们的计算逻辑是有缺陷的，\n# 最后一个数字没有经过我们的计算，甚至连进入栈的资格都没有。要想让最后一个数字被计算并且\n# 能进栈，必须在字符串内容读取完了之后，还要再读取一个非数字和计算符号的字符，这样就会\n# 进入到else的状态中，把最后一个数字输入进栈，并且进行判断是否计算，才能得到最终的结果。\n\n# 接下来就要去计算$了\n# 先把栈中的第一个元素记录下来，通过变量res进行存储，然后挨个循环列表跟res进行$计算，\n# 再把结果记为res，最终就会得出答案\nres = store[0]\nfor i in store[1:]:\n  res = cal_dollor(res,i)\n\nprint(res)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "HUAWEIOD",
    "section": "",
    "text": "Preface\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books."
  },
  {
    "objectID": "Hash.html#lc349.-两个数组的交集",
    "href": "Hash.html#lc349.-两个数组的交集",
    "title": "4  哈希",
    "section": "4.2 LC349. 两个数组的交集",
    "text": "4.2 LC349. 两个数组的交集\n\n4.2.1 题目描述\n给定两个数组nums1和nums2，返回它们的交集。输出结果中的每个元素一定是唯一的。我们可以不考虑输出结果的顺序。\n示例一：\n\n输入：nums1 = [1,2,2,1], nums2 = [2,2]\n\n\n输出：[2]\n\n示例二：\n\n输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n\n\n输出：[9, 4]\n\n\n解释：[4, 9]也是可通过的\n\n提示：\n\n1 &lt;= nums1.length, nums2.length &lt;= 1000\n0 &lt;= nums1[i], nums2[i] &lt;= 1000\n\n\n\n4.2.2 解题思路\n我们发现给我们的两个数组，其实里面的元素是有重复的，我们最终比较的是两个数组中唯一的元素之交集。\n所以，第一步我们要把两个数组化成元素是唯一的数据结构，怎么做呢？直接去用set(list)这种方式，它能返回一个不带重复元素的元组。然后直接返回两个元组的交集即可。\n\n\n4.2.3 代码展示\n\nclass Solution:\n    def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:\n        nums1 = set(nums1)\n        nums2 = set(nums2)\n        return (list(nums1 & nums2)) # python的交集是&,并集是|"
  },
  {
    "objectID": "Hash.html#有效的字母异位词",
    "href": "Hash.html#有效的字母异位词",
    "title": "4  哈希",
    "section": "4.3 242. 有效的字母异位词",
    "text": "4.3 242. 有效的字母异位词\n\n4.3.1 题目描述\n给定两个字符串s和t，编写一个函数来判断t是否是s的字母异位词。\n注意：若s和t中每个字符出现的次数都相同,则称s和t互为字母异位词。\n示例一：\n\n输入：s = “anagram”, t = “nagaram”\n\n\n输出：true\n\n示例二：\n\n输入: s = “rat”, t = “car”\n\n\n输出：false\n\n提示：\n\n1 &lt;= s.length, t.length &lt;= 5 * 104\ns 和 t仅包含小写字母\n\n\n\n4.3.2 解题思路\n题目中说输入的两个字符串都只是小写字母，而小写字母一共有二十六个。我们可以设立一个26位长度的list，list中的每一个元素的值都为0。首先去遍历第一个输入的s字符串，如果遇到一个元素把它对应的那个小写字母的位置+1，那么整体遍历完了之后，我们得到的list中的元素对应的位置的数量就是这个字母在这个s字符串中出现的次数。然后紧接着，我们要遍历第二个字符串t，这回不一样了，遇到了小写字母的话，要在对应的位置上减一，如果某个位置上出现了负数，就说明第二个字符串比第一个字符串针对同样的字母至少多一个，那就肯定不是字母异位词，就返回False，如果最后遍历完，数组变成了0，那么就说明两个字符串中对应的小写字母出现的次数相同，返回True。\n\n\n4.3.3 代码展示\n\nclass Solution:\n    def isAnagram(self, s: str, t: str) -&gt; bool:\n        #构建一个26位长度的元素为0的数组\n        store = [0] * 26\n        #遍历s\n        for ch in s:\n            #确定遍历的字符是哪个小写字母，它的位置在哪\n            loc = ord(ch) - ord('a')\n            #对应位置加一\n            store[loc] += 1\n        for ch in t:\n            loc = ord(ch) - ord('a')\n            #对应位置减一\n            store[loc] -= 1\n            # 判断是否有小于0的负数出现，如果有，则返回False\n            if store[loc] &lt; 0:\n                return False\n        # 如果一直没返回False，则说明第二个字符串的字符没有比\n        # 第一个字符串中多的，但是也不能返回True，因为万一s比t\n        # 多呢？\n        if sum(store) == 0:\n            return True\n        else:\n            return False"
  },
  {
    "objectID": "Hash.html#lc242.-有效的字母异位词",
    "href": "Hash.html#lc242.-有效的字母异位词",
    "title": "4  哈希",
    "section": "4.3 LC242. 有效的字母异位词",
    "text": "4.3 LC242. 有效的字母异位词\n\n4.3.1 题目描述\n给定两个字符串s和t，编写一个函数来判断t是否是s的字母异位词。\n注意：若s和t中每个字符出现的次数都相同,则称s和t互为字母异位词。\n示例一：\n\n输入：s = “anagram”, t = “nagaram”\n\n\n输出：true\n\n示例二：\n\n输入: s = “rat”, t = “car”\n\n\n输出：false\n\n提示：\n\n1 &lt;= s.length, t.length &lt;= 5 * 104\ns 和 t仅包含小写字母\n\n\n\n4.3.2 解题思路\n题目中说输入的两个字符串都只是小写字母，而小写字母一共有二十六个。我们可以设立一个26位长度的list，list中的每一个元素的值都为0。首先去遍历第一个输入的s字符串，如果遇到一个元素把它对应的那个小写字母的位置+1，那么整体遍历完了之后，我们得到的list中的元素对应的位置的数量就是这个字母在这个s字符串中出现的次数。然后紧接着，我们要遍历第二个字符串t，这回不一样了，遇到了小写字母的话，要在对应的位置上减一，如果某个位置上出现了负数，就说明第二个字符串比第一个字符串针对同样的字母至少多一个，那就肯定不是字母异位词，就返回False，如果最后遍历完，数组变成了0，那么就说明两个字符串中对应的小写字母出现的次数相同，返回True。\n\n\n4.3.3 代码展示\n\nclass Solution:\n    def isAnagram(self, s: str, t: str) -&gt; bool:\n        #构建一个26位长度的元素为0的数组\n        store = [0] * 26\n        #遍历s\n        for ch in s:\n            #确定遍历的字符是哪个小写字母，它的位置在哪\n            loc = ord(ch) - ord('a')\n            #对应位置加一\n            store[loc] += 1\n        for ch in t:\n            loc = ord(ch) - ord('a')\n            #对应位置减一\n            store[loc] -= 1\n            # 判断是否有小于0的负数出现，如果有，则返回False\n            if store[loc] &lt; 0:\n                return False\n        # 如果一直没返回False，则说明第二个字符串的字符没有比\n        # 第一个字符串中多的，但是也不能返回True，因为万一s比t\n        # 多呢？\n        if sum(store) == 0:\n            return True\n        else:\n            return False"
  },
  {
    "objectID": "Hash.html#lc383.-赎金信",
    "href": "Hash.html#lc383.-赎金信",
    "title": "4  哈希",
    "section": "4.4 LC383. 赎金信",
    "text": "4.4 LC383. 赎金信\n\n4.4.1 题目描述\n给你两个字符串：ransomNote和magazine，判断ransomNote能不能由magazine里面的字符构成。\n如果可以，返回true；否则返回false。\nmagazine中的每个字符只能在ransomNote中使用一次。\n示例一：\n\n输入：ransomNote = “a”, magazine = “b”\n\n\n输出: false\n\n示例二：\n\n输入：ransomNote = “aa”, magazine = “ab”\n\n\n输出：false\n\n示例三：\n\n输入：ransomNote = “aa”, magazine = “aab”\n\n\n输出：true\n\n提示：\n\n1 &lt;= ransomNote.length, magazine.length &lt;= 105\nransomNote和magazine由小写英文字母组成\n\n\n\n4.4.2 解题思路\n这道题跟上一道题很像啊，应该可以用同样的套路去解题。可以发现，ransomNote中的字符是从magazine中拿的，我们可以设立一个元素全为0的26位长度的list，然后去遍历magazine，遇到小写字母就在对应的位置上+=1，这样遍历完成之后，得到的list是magazine中的每个小写字母的数量。之后遇到ransomNote，我们继续遍历，遇到一个字母就减去一。这样跟上道题一样，如果出现了负数，则说明对应的小写字母ransomNote要比magazine要多，这样就返回False。如果最后每一个字母的数量中都没有小于0的，说明magazine中的字母数量很多，足够ransomNote取，就返回True。\n\n\n4.4.3 代码展示\n\nclass Solution:\n    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:\n        #构建一个26位长度的元素皆为0的list\n        store = [0] * 26\n        #遍历magazine\n        for ch in magazine:\n            #记录ch对应的位置\n            loc = ord(ch) - ord('a')\n            #ord函数是返回传入字符的Unicode码点，小写字母a到z的码点是连在一起的，\n            #所以ch相减a的ord返回值，就能得出它在26位小写字母中的位置了。\n            store[loc] += 1\n\n        for ch in ransomNote:\n            loc = ord(ch) - ord('a')\n            store[loc] -= 1\n            #判断是否有负数出现，如果出现负数，说明magazine的库存不够了，就返回False\n            if store[loc] &lt; 0:\n                return False\n        #如果magazine的库存不够用，它就不会走到这里。如果走到了这里，说明库存要么刚好够用，要么就多出来一些小写字母\n        #无论哪种情况，这都是允许的，返回True\n        return True"
  },
  {
    "objectID": "Hash.html#哈希表2023q1a-集五福",
    "href": "Hash.html#哈希表2023q1a-集五福",
    "title": "4  哈希",
    "section": "4.5 【哈希表】2023Q1A-集五福",
    "text": "4.5 【哈希表】2023Q1A-集五福\n\n4.5.1 题目描述\n集五福作为近年来大家喜闻乐见迎新春活动，集合爱国福、富强福、和谐福、友善福、敬业福即可分享超级大红包。以0和1组成的长度为5的字符串代表每个人所得到的福卡，每一位代表一种福卡，1表示已经获得该福卡，单类型福卡不超过1张，随机抽取一个小于10人团队，求该团队最多可以集齐多少套五福？\n输入\n输入若干个由0、1组成的长度等于5的字符串，代表团队中每个福卡获得情况\n注意：1人也可以是一个团队\n注意2:1人可以有0到5张福卡，但福卡不能重复\n输出\n输出该团队最多能凑齐多少套五福\n示例一\n\n输入：11001,11101\n\n\n输出：0\n\n示例二\n\n输入：11101,10111\n\n\n输出：1\n\n\n\n4.5.2 解题思路\n我们首先应该把输入的字符串根据有多少人分成多少部分，最好化成数字类型，然后把这些部分相加，得到一个五位数据的数据结构，然后这五个数中最少的一个数，就是这些人能凑齐的最多五福。\n\n\n4.5.3 代码展示\n\n'''\n要用Counter的API去做这道题，在Counter中输入一个字符串，它会\n返回一个对象，结果展示是Counter（字典），所以特别想一个字典，\n其中key是字符串中的每个字符，value是这个字符串中对应字符的个数。\n然后，因为它是一个对象，你也可以像调取list中的数一样，输出\nCounter[index]，就能把对应的值展现出来。\n'''\nfrom collections import Counter\n\n# 先开始读取输入的字符串,用split()返回一个数组\nstore = input().split(\",\")\n# 先构建一个Counter对象\n# Counter相对于dict的好处是即使没有这个Index，也可以直接\n# 按照Counter[Index] = value 的方式把值放进去，而不用考虑\n# 指针越界的问题\nc = Counter()\n\n#我们要读取每个人的五福种类的数量，我们以种类作为key，很显然\n#这个种类我们就把它设为0，1等的Index。那我们需要既提取每个人\n#的Index和value。\n\nfor ch in store:\n    # enumerate()返回一个对象的index和value·\n    for j,k in enumerate(ch):\n        #如果个人的五福种类对应的数值是0，就代表他没有这个对应的五福\n        #如果个人的五福种类对应的数值是1，就代表他有这个对应的服务\n        #所以如果是1的话，Counter对应的种类数值+1\n        #如果是0的话，就不要改变\n        if k == \"1\":\n            c[j] += 1\n\n# 把所有人的情况遍历后，我们得到的Counter，包含小组整体各个五福种类\n# 有多少数量的数目。这里会出现两种情况，一是这个小组五个种类的福都有，\n# 那么Counter反应的是每个种类有多少数目；第二种情况是这个小组针对某个\n# 种类的五福连一个都没有，如果是这种情况要直接返回0，如果是第一种情况\n# 要返回五个种类的数目最小值\n\nprint(0 if len(c) &lt; 5 else min(c.values()))"
  },
  {
    "objectID": "Hash.html#哈希表2023q1a-删除最少字符",
    "href": "Hash.html#哈希表2023q1a-删除最少字符",
    "title": "4  哈希",
    "section": "4.6 【哈希表】2023Q1A-删除最少字符",
    "text": "4.6 【哈希表】2023Q1A-删除最少字符\n\n4.6.1 题目描述\n删除字符串s中出现次数最少的字符，如果多个字符出现次数一样则都删除。\n输入\n输入只包含小写字母\n输出描述\n输出删除后剩余的字符串；若删除后字符串长度为0，则输出字符串\"empty\"\n示例一\n\n输入：abcdd\n\n\n输出：dd\n\n示例二\n\n输入：aabbccdd\n\n\n输出：empty\n\n\n\n4.6.2 解题思路\n我们首先应该把字符串输入进来，而且要设置一个数据结构，这个数据结构类似于字典，至于是不是Counter，一会再说。我们要储存的内容是字符为key，对应出现的次数为value。这里看来直接用Counter吧，这样直接输入Counter(str)，我们就能反映出str的字符的个数。\n\n\n4.6.3 代码展示\n\ns = input()\nfrom collections import Counter\nc = Counter(s)\n#找到存储数据的结构中的元素对应的最小值\nmins = c[min(c)] #min（c）只是返回key，要想去调取里面的value，必须用c[key]\n#查看那些字符是最小的，这里还要设立一个数据结构去储存最小值对应的字符\nminstr = set()\nfor ch in c:#这里的ch是c的key\n    if c[ch] == mins:#查看值是否是等于最小值，要调用字典的查找value的办法dict[key]\n        minstr.add(ch)\n#输出的结果设置成变量为res，我们遍历s，如果遍历的字符不是在minstr中，\n#把它放在res中，如果是把它就不加\nres = ''\nfor i in s:\n    if i not in minstr:\n        res += i\n#如果返回结果res不为空，就返回它。如果为空，要返回empty\n\nprint(res if res else 'empty')"
  },
  {
    "objectID": "Hash.html#lc1.-两数之和",
    "href": "Hash.html#lc1.-两数之和",
    "title": "4  哈希",
    "section": "4.7 LC1. 两数之和",
    "text": "4.7 LC1. 两数之和\n\n4.7.1 题目描述\n给定一个整数数组nums和一个整数目标值target，请你在该数组中找出和为目标值target的那两个整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n你可以按任意顺序返回答案。\n示例一：\n\n输入：nums = [2,7,11,15], target = 9\n\n\n输出：[0,1]\n\n\n解释：因为 nums[0] + nums[1] == 9, 返回[0, 1]。\n\n示例二：\n\n输入：nums = [3,2,4], target = 6\n\n\n输出：[1,2]\n\n示例三：\n\n输入：nums = [3,3], target = 6\n\n\n输出：[0,1]\n\n提示：\n\n2 &lt;= nums.length &lt;= 104\n-109 &lt;= nums[i] &lt;= 109\n-109 &lt;= target &lt;= 109\n只会存在一个有效答案\n\n\n\n4.7.2 解题思路\n这道题让我们返回的结果是数组中的Index，我们可以用一个字典来逐个提取list中的元素和它的index，这里要把index设为字典的value，而把list中的元素的值设为字典的key。为什么这样呢？因为我们遍历字典的时候返回的是key，这样可以直接进行对比，最后返回字典的值正好是list中的Index，比较符合我们的固有观念，数据结构中存在的值是返回的最终结果。\n当提取了一个list中的元素后，我们要将target减去这个key，看看剩下的值是不是字典中固有的key，如果是，则直接把提取元素的Index和原有的元素的key合成一个list返回即可。如果不是则进行下一个元素的提取。如果遍历完事之后，还没发现有能返回的情况，就说明这个列表中的元素不能组成target值，我们应该返回False，但是本题说明肯定会有一个解，那咱就不考虑这种情况发生了。\n\n\n4.7.3 代码展示\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:\n        #构建一个dict，储存遍历数组的信息，以list的值为key，以list的index为值\n        store = dict()\n        #遍历数组，要提取每个元素的值和Index，这里要用enumerate函数\n        for i,j in enumerate(nums):\n            if target - j in store:\n                return [i,store[target - j]] \n                #这里就显示出了用key来进行dict里内容的对比的好处，如果这个值是dict的key\n                #就可以直接调用value的内容了，相反如果把index作为dict的key，list的元素\n                #作为dict的值，那我们如果要调用dict某一元素特定的key是很难的，但是调用\n                #其的value是很容易的，直接把对应的key输入进去就行了。所以，我们在今后做\n                #算法题的时候，一定要把返回的东西设为字典的value。\n            else:\n                store[j] = i"
  },
  {
    "objectID": "Hash.html#代码展示-6",
    "href": "Hash.html#代码展示-6",
    "title": "4  哈希",
    "section": "4.8 代码展示",
    "text": "4.8 代码展示\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:\n        #构建一个dict，储存遍历数组的信息，以list的值为key，以list的index为值\n        store = dict()\n        #遍历数组，要提取每个元素的值和Index，这里要用enumerate函数\n        for i,j in enumerate(List):\n            if target - j in store:\n                return [i,store[target - j]] \n                #这里就显示出了用key来进行dict里内容的对比的好处，如果这个值是dict的key\n                #就可以直接调用value的内容了，相反如果把index作为dict的key，list的元素\n                #作为dict的值，那我们如果要调用dict某一元素特定的key是很难的，但是调用\n                #其的value是很容易的，直接把对应的key输入进去就行了。所以，我们在今后做\n                #算法题的时候，一定要把返回的东西设为字典的value。\n            else:\n                store[j] = i"
  },
  {
    "objectID": "Hash.html#lc219.-存在重复元素-ii",
    "href": "Hash.html#lc219.-存在重复元素-ii",
    "title": "4  哈希",
    "section": "4.8 LC219. 存在重复元素 II",
    "text": "4.8 LC219. 存在重复元素 II\n\n4.8.1 题目描述\n给你一个整数数组nums和一个整数k，判断数组中是否存在两个不同的索引i和j，满足nums[i] == nums[j]且abs(i - j) &lt;= k。如果存在，返回true；否则，返回false。\n示例一：\n\n输入：nums = [1,2,3,1], k = 3\n\n\n输出：true\n\n示例二：\n\n输入：nums = [1,0,1,1], k = 1\n\n\n输出：true\n\n示例三：\n\n输入：nums = [1,2,3,1,2,3], k = 2\n\n\n输出：false\n\n提示\n\n1 &lt;= nums.length &lt;= 105\n-109 &lt;= nums[i] &lt;= 109\n0 &lt;= k &lt;= 105\n\n\n\n4.8.2 解题思路\n首先我们还是要用dict来去储存nums的信息，因为这里面涉及到两方面的比较，一个是value的比较，另一个是Index的比较。其中第一步要比较的是value，如果value值相同，我们再去比较两个相同值的Index差值。这里把value作为key，把Index作为字典的value。\n每遍历一个元素，我们都要把它的值和字典中已有的每个key进行，比较，如果key相同，则进行Index的差值计算。如果这个差值小于k，则说明成功，返回true，如果全部遍历完还没有成功的，那就意味着传入的list里的元素没有符合这个条件的，返回False。\n\n\n4.8.3 代码展示\n\nclass Solution:\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -&gt; bool:\n        #构建一个字典，一般涉及到两个维度的比较都要用字典\n        store = dict()\n        #开始去遍历数组中的元素，提取Index和value\n        for i,j in enumerate(nums):\n            #先判断value是否相等\n            if j in store:\n                #大家想想如果list的value不作为key的话，\n                #想要查看这个value是否在dict中的话，得有\n                #多费劲\n                '''\n                这里要考虑一种情况，比如说输入的例子是[1,2,3,1,1,4,5]，2这种情况，当\n                遍历到第二个1的时候，发现值虽然相同，但是Index的距离太远，这时我们要存储\n                第二个一，我们又是以list的value作为dict的key的。这时储存的就是dict[1]=3。\n                势必要把第一个一给代替掉（字典作为哈希表的特点是不在乎顺序），我们care不care\n                ，我们真正care的是最新的1的index，因为第一个1如果第一次配对失败，它就再也没有\n                机会成功配对了，我们要记录最新的1，因为它是有可能配对的，如果我们用list去储存\n                遍历的元素，就要考虑那个是最新的1了，这里再对比配对的话就非常麻烦，而用字典我们\n                每次储存的都是最新的值所拥有的Index。\n                '''\n                #这里判断index之差是否大于小于等于k\n                if i - store[j] &lt;= k:\n                    return True\n            store[j] = i\n\n        #如果都没有遍历都没有成功，则返回False\n        return False"
  }
]